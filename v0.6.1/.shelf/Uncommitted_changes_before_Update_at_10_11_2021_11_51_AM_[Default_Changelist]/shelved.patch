Index: src/main/java/me/derp/quantum/features/modules/render/PopChams.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package me.derp.quantum.features.modules.render;\r\n\r\nimport me.derp.quantum.event.events.TotemPopEvent;\r\nimport me.derp.quantum.features.command.Command;\r\nimport me.derp.quantum.features.modules.Module;\r\nimport me.derp.quantum.features.setting.Setting;\r\nimport me.derp.quantum.util.EntityUtil;\r\nimport net.minecraft.client.entity.EntityOtherPlayerMP;\r\nimport net.minecraft.entity.Entity;\r\nimport net.minecraft.world.GameType;\r\nimport net.minecraftforge.fml.common.eventhandler.SubscribeEvent;\r\n\r\nimport java.awt.*;\r\nimport java.util.ArrayList;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\n\r\npublic class PopChams\r\n        extends Module {\r\n    public static PopChams INSTANCE = new PopChams();\r\n    public Setting<Integer> red = this.register(new Setting<Object>(\"Red\", 0, 0, 255));\r\n    public Setting<Integer> green = this.register(new Setting<Object>(\"Green\", 255, 0, 255));\r\n    public Setting<Integer> blue = this.register(new Setting<Object>(\"Blue\", 0, 0, 255));\r\n    public Setting<Integer> alpha = this.register(new Setting<>(\"Alpha\", 255, 0, 255));\r\n\r\n    public PopChams() {\r\n        super(\"PopChams\", \"1 origianl module from kambing\", Module.Category.RENDER, false, false, false);\r\n    }\r\n\r\n    public static PopChams getINSTANCE() {\r\n        if (INSTANCE == null) {\r\n            INSTANCE = new PopChams();\r\n        }\r\n        return INSTANCE;\r\n    }\r\n\r\n    public void setInstance() {\r\n        INSTANCE = this;\r\n    }\r\n\r\n    public static ConcurrentHashMap<Integer, Integer> pops = new ConcurrentHashMap<>();\r\n\r\n    @SubscribeEvent\r\n    public void onPopLol(TotemPopEvent event) {\r\n        Color color = EntityUtil.getColor(event.getEntity(), this.red.getValue(), this.green.getValue(), this.blue.getValue(), this.alpha.getValue(), false);\r\n        if (event.getEntity() != mc.player) {\r\n            Entity ee = event.getEntity();\r\n            Command.sendMessage(\"PopEventLol\"); // this looks like wurst+ 3\r\n            ArrayList<Integer> idList = new ArrayList<>();\r\n            for (Entity e : mc.world.loadedEntityList) {\r\n                idList.add(e.entityId);\r\n            }\r\n            EntityOtherPlayerMP popCham = new EntityOtherPlayerMP(mc.world, event.getEntity().getGameProfile());\r\n            popCham.copyLocationAndAnglesFrom(ee);\r\n            popCham.rotationYawHead = ee.getRotationYawHead();\r\n            popCham.rotationYaw = ee.rotationYaw;\r\n            popCham.rotationPitch = ee.rotationPitch;\r\n            popCham.setGameType(GameType.CREATIVE);\r\n            popCham.setHealth(20);\r\n            for (int i = 0; i > -10000; i--) {\r\n                if (!idList.contains(i)) {\r\n                    mc.world.addEntityToWorld(i, popCham);\r\n                    pops.put(i, color.getAlpha());\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/me/derp/quantum/features/modules/render/PopChams.java b/src/main/java/me/derp/quantum/features/modules/render/PopChams.java
--- a/src/main/java/me/derp/quantum/features/modules/render/PopChams.java	(revision 7b4fc7b1b7f98d347c60677eb835323ad7521d92)
+++ b/src/main/java/me/derp/quantum/features/modules/render/PopChams.java	(date 1636444002022)
@@ -1,69 +1,122 @@
+/*
+ * Decompiled with CFR 0.151.
+ */
 package me.derp.quantum.features.modules.render;
 
-import me.derp.quantum.event.events.TotemPopEvent;
-import me.derp.quantum.features.command.Command;
+import com.mojang.authlib.GameProfile;
+import me.derp.quantum.event.events.PacketEvent;
+import me.derp.quantum.event.events.Render3DEvent;
 import me.derp.quantum.features.modules.Module;
 import me.derp.quantum.features.setting.Setting;
-import me.derp.quantum.util.EntityUtil;
 import net.minecraft.client.entity.EntityOtherPlayerMP;
+import net.minecraft.client.renderer.GlStateManager;
+import net.minecraft.client.renderer.entity.RenderManager;
 import net.minecraft.entity.Entity;
-import net.minecraft.world.GameType;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.network.play.server.SPacketEntityStatus;
+import net.minecraft.world.World;
 import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+import org.lwjgl.opengl.GL11;
 
 import java.awt.*;
-import java.util.ArrayList;
-import java.util.concurrent.ConcurrentHashMap;
-
 
 public class PopChams
         extends Module {
-    public static PopChams INSTANCE = new PopChams();
-    public Setting<Integer> red = this.register(new Setting<Object>("Red", 0, 0, 255));
-    public Setting<Integer> green = this.register(new Setting<Object>("Green", 255, 0, 255));
-    public Setting<Integer> blue = this.register(new Setting<Object>("Blue", 0, 0, 255));
-    public Setting<Integer> alpha = this.register(new Setting<>("Alpha", 255, 0, 255));
+    public static Setting<Boolean> angel = new Setting<>("Angel", false);
+    public static Setting<Integer> angelSpeed = new Setting<>("AngelSpeed", 150, 10, 500);
+    public static Setting<Integer> fadeSpeed = new Setting<>("FadeSpeed", 200, 10, 500);
+    public static Setting<Double> width = new Setting<>("Width", Double.longBitsToDouble(Double.doubleToLongBits(0.10667784123174527) ^ 0x7FB34F3D2F4C588FL), Double.longBitsToDouble(Double.doubleToLongBits(2.8356779810862056) ^ 0x7FE6AF77EFF6053EL), Double.longBitsToDouble(Double.doubleToLongBits(0.14239240361793695) ^ 0x7FD639EA0E5E7291L));
+    public static Setting<Integer> fillR = new Setting<>("FillR", 255, 0, 255);
+    public static Setting<Integer> fillG = new Setting<>("FillG", 255, 0, 255);
+    public static Setting<Integer> fillB = new Setting<>("FillB", 255, 0, 255);
+    public static Setting<Integer> fillA = new Setting<>("FillA", 255, 0, 255);
+    public static Setting<Integer> outR = new Setting<>("OutR", 255, 0, 255);
+    public static Setting<Integer> outG = new Setting<>("OutG", 255, 0, 255);
+    public static Setting<Integer> outB = new Setting<>("OutB", 255, 0, 255);
+    public static Setting<Integer> outA = new Setting<>("OutA", 180, 0, 255);
+    public static Color color;
+    public static Color outlineColor;
+    public static EntityOtherPlayerMP player;
+    public static EntityPlayer entity;
+    public long startTime;
+    public static float opacity;
+    public static long time;
+    public static long duration;
+    public static float startAlpha;
+    RenderManager renderManager;
 
     public PopChams() {
-        super("PopChams", "1 origianl module from kambing", Module.Category.RENDER, false, false, false);
-    }
+        super("PopChams", "Renders a cham which fades out when a player pops.", Category.RENDER, true, false, false);
+        register(angel);
+        register(angelSpeed);
+        register(fadeSpeed);
+        register(width);
+        register(fillR);
+        register(fillG);
+        register(fillB);
+        register(fillA);
+        register(outR);
+        register(outB);
+        register(outG);
+        register(outA);
 
-    public static PopChams getINSTANCE() {
-        if (INSTANCE == null) {
-            INSTANCE = new PopChams();
-        }
-        return INSTANCE;
     }
-
-    public void setInstance() {
-        INSTANCE = this;
-    }
-
-    public static ConcurrentHashMap<Integer, Integer> pops = new ConcurrentHashMap<>();
 
     @SubscribeEvent
-    public void onPopLol(TotemPopEvent event) {
-        Color color = EntityUtil.getColor(event.getEntity(), this.red.getValue(), this.green.getValue(), this.blue.getValue(), this.alpha.getValue(), false);
-        if (event.getEntity() != mc.player) {
-            Entity ee = event.getEntity();
-            Command.sendMessage("PopEventLol"); // this looks like wurst+ 3
-            ArrayList<Integer> idList = new ArrayList<>();
-            for (Entity e : mc.world.loadedEntityList) {
-                idList.add(e.entityId);
+    public void onReceive(final PacketEvent.Receive event) {
+        if (PopChams.mc.player != null && PopChams.mc.world != null) {
+            if (event.getPacket() instanceof SPacketEntityStatus) {
+                final SPacketEntityStatus packet = event.getPacket();
+                if (packet.getEntity(PopChams.mc.world) instanceof EntityPlayer) {
+                    PopChams.entity = (EntityPlayer)packet.getEntity(PopChams.mc.world);
+                    if (packet.getOpCode() == 35) {
+                        if (PopChams.entity != null) {
+                            if (PopChams.entity != PopChams.mc.player) {
+                                final GameProfile profile = new GameProfile(PopChams.mc.player.getUniqueID(), "");
+                                (PopChams.player = new EntityOtherPlayerMP(PopChams.mc.world, profile)).copyLocationAndAnglesFrom(packet.getEntity(PopChams.mc.world));
+                                PopChams.player.rotationYaw = PopChams.entity.rotationYaw;
+                                PopChams.player.rotationYawHead = PopChams.entity.rotationYawHead;
+                                PopChams.player.rotationPitch = PopChams.entity.rotationPitch;
+                                PopChams.player.prevRotationPitch = PopChams.entity.prevRotationPitch;
+                                PopChams.player.prevRotationYaw = PopChams.entity.prevRotationYaw;
+                                PopChams.player.renderYawOffset = PopChams.entity.renderYawOffset;
+                                this.startTime = System.currentTimeMillis();
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+
+
+    @Override
+    public void onRender3D(Render3DEvent eventRender3D) {
+        block6: {
+            if (PopChams.mc.player == null || PopChams.mc.world == null) {
+                return;
             }
-            EntityOtherPlayerMP popCham = new EntityOtherPlayerMP(mc.world, event.getEntity().getGameProfile());
-            popCham.copyLocationAndAnglesFrom(ee);
-            popCham.rotationYawHead = ee.getRotationYawHead();
-            popCham.rotationYaw = ee.rotationYaw;
-            popCham.rotationPitch = ee.rotationPitch;
-            popCham.setGameType(GameType.CREATIVE);
-            popCham.setHealth(20);
-            for (int i = 0; i > -10000; i--) {
-                if (!idList.contains(i)) {
-                    mc.world.addEntityToWorld(i, popCham);
-                    pops.put(i, color.getAlpha());
-                    break;
+            color = new Color(fillR.getValue(), fillG.getValue(), fillB.getValue(), fillA.getValue());
+            outlineColor = new Color(outR.getValue(), outG.getValue(), outB.getValue(), outA.getValue());
+            opacity = Float.intBitsToFloat(Float.floatToIntBits(1.6358529E38f) ^ 0x7EF622C3);
+            time = System.currentTimeMillis();
+            duration = time - this.startTime;
+            startAlpha = (float)outA.getValue() / Float.intBitsToFloat(Float.floatToIntBits(0.0119778095f) ^ 0x7F3B3E93);
+            if (player == null || entity == null) break block6;
+            if (duration < (long)(fadeSpeed.getValue().intValue() * 10)) {
+                opacity = startAlpha - (float)duration / (float)(fadeSpeed.getValue().intValue() * 10);
+            }
+            if (duration < (long)(fadeSpeed.getValue().intValue() * 10)) {
+                GL11.glPushMatrix();
+                if (angel.getValue()) {
+                    GlStateManager.translate(Float.intBitsToFloat(Float.floatToIntBits(1.240196E38f) ^ 0x7EBA9A9D), (float)duration / (float)(angelSpeed.getValue().intValue() * 10), Float.intBitsToFloat(Float.floatToIntBits(3.0414126E38f) ^ 0x7F64CF7A));
                 }
+                mc.getRenderManager().renderEntityStatic(player, Float.intBitsToFloat(Float.floatToIntBits(6.159893f) ^ 0x7F451DD8), false);
+                GlStateManager.translate(Float.intBitsToFloat(Float.floatToIntBits(3.0715237E38f) ^ 0x7F671365), Float.intBitsToFloat(Float.floatToIntBits(1.9152719E37f) ^ 0x7D668ADF), Float.intBitsToFloat(Float.floatToIntBits(1.9703683E38f) ^ 0x7F143BEA));
+                GL11.glPopMatrix();
             }
         }
     }
 }
+
Index: src/main/java/me/derp/quantum/features/modules/combat/AutoCrystal.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package me.derp.quantum.features.modules.combat;\r\n\r\n\r\nimport com.mojang.authlib.GameProfile;\r\nimport io.netty.util.internal.ConcurrentSet;\r\nimport me.derp.quantum.Quantum;\r\nimport me.derp.quantum.event.events.ClientEvent;\r\nimport me.derp.quantum.event.events.PacketEvent;\r\nimport me.derp.quantum.event.events.Render3DEvent;\r\nimport me.derp.quantum.event.events.UpdateWalkingPlayerEvent;\r\nimport me.derp.quantum.features.command.Command;\r\nimport me.derp.quantum.features.gui.OyVeyGui;\r\nimport me.derp.quantum.features.modules.Module;\r\nimport me.derp.quantum.features.modules.client.ClickGui;\r\nimport me.derp.quantum.features.setting.Bind;\r\nimport me.derp.quantum.features.setting.Setting;\r\nimport me.derp.quantum.util.Timer;\r\nimport me.derp.quantum.util.*;\r\nimport net.minecraft.block.Block;\r\nimport net.minecraft.block.state.IBlockState;\r\nimport net.minecraft.client.entity.EntityOtherPlayerMP;\r\nimport net.minecraft.entity.Entity;\r\nimport net.minecraft.entity.item.EntityEnderCrystal;\r\nimport net.minecraft.entity.player.EntityPlayer;\r\nimport net.minecraft.init.Blocks;\r\nimport net.minecraft.init.Items;\r\nimport net.minecraft.init.SoundEvents;\r\nimport net.minecraft.item.ItemEndCrystal;\r\nimport net.minecraft.item.ItemPickaxe;\r\nimport net.minecraft.network.play.client.CPacketAnimation;\r\nimport net.minecraft.network.play.client.CPacketPlayer;\r\nimport net.minecraft.network.play.client.CPacketUseEntity;\r\nimport net.minecraft.network.play.server.*;\r\nimport net.minecraft.util.EnumFacing;\r\nimport net.minecraft.util.EnumHand;\r\nimport net.minecraft.util.SoundCategory;\r\nimport net.minecraft.util.math.AxisAlignedBB;\r\nimport net.minecraft.util.math.BlockPos;\r\nimport net.minecraft.util.math.RayTraceResult;\r\nimport net.minecraft.util.math.Vec3d;\r\nimport net.minecraftforge.fml.common.eventhandler.EventPriority;\r\nimport net.minecraftforge.fml.common.eventhandler.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.gameevent.InputEvent;\r\nimport org.lwjgl.input.Keyboard;\r\nimport org.lwjgl.input.Mouse;\r\n\r\nimport java.awt.*;\r\nimport java.util.List;\r\nimport java.util.Queue;\r\nimport java.util.*;\r\nimport java.util.concurrent.*;\r\nimport java.util.concurrent.atomic.AtomicBoolean;\r\n\r\npublic class AutoCrystal\r\n        extends Module {\r\n    public static EntityPlayer target = null;\r\n    public static Set<BlockPos> lowDmgPos = new ConcurrentSet<>();\r\n    public static Set<BlockPos> placedPos = new HashSet<>();\r\n    public static Set<BlockPos> brokenPos = new HashSet<>();\r\n    private static AutoCrystal instance;\r\n    public final me.derp.quantum.util.Timer threadTimer = new me.derp.quantum.util.Timer();\r\n    private final Setting<Settings> setting = this.register(new Setting<>(\"Settings\", Settings.PLACE));\r\n    public final Setting<Boolean> attackOppositeHand = this.register(new Setting<Object>(\"OppositeHand\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV));\r\n    public final Setting<Boolean> removeAfterAttack = this.register(new Setting<Object>(\"AttackRemove\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV));\r\n    public final Setting<Boolean> antiBlock = this.register(new Setting<Object>(\"AntiFeetPlace\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV));\r\n    private final Setting<Integer> switchCooldown = this.register(new Setting<Object>(\"Cooldown\", 500, 0, 1000, v -> this.setting.getValue() == Settings.MISC));\r\n    private final Setting<Integer> eventMode = this.register(new Setting<Object>(\"Updates\", 3, 1, 3, v -> this.setting.getValue() == Settings.DEV));\r\n    private final me.derp.quantum.util.Timer switchTimer = new me.derp.quantum.util.Timer();\r\n    private final me.derp.quantum.util.Timer manualTimer = new me.derp.quantum.util.Timer();\r\n    private final me.derp.quantum.util.Timer breakTimer = new me.derp.quantum.util.Timer();\r\n    private final me.derp.quantum.util.Timer placeTimer = new me.derp.quantum.util.Timer();\r\n    private final me.derp.quantum.util.Timer syncTimer = new me.derp.quantum.util.Timer();\r\n    private final me.derp.quantum.util.Timer predictTimer = new me.derp.quantum.util.Timer();\r\n    private final me.derp.quantum.util.Timer renderTimer = new me.derp.quantum.util.Timer();\r\n    private final AtomicBoolean shouldInterrupt = new AtomicBoolean(false);\r\n    private final me.derp.quantum.util.Timer syncroTimer = new me.derp.quantum.util.Timer();\r\n    private final Map<EntityPlayer, me.derp.quantum.util.Timer> totemPops = new ConcurrentHashMap<>();\r\n    private final Queue<CPacketUseEntity> packetUseEntities = new LinkedList<>();\r\n    private final AtomicBoolean threadOngoing = new AtomicBoolean(false);\r\n    public Setting<Raytrace> raytrace = this.register(new Setting<Object>(\"Raytrace\", Raytrace.NONE, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Boolean> place = this.register(new Setting<Object>(\"Place\", Boolean.TRUE, v -> this.setting.getValue() == Settings.PLACE));\r\n    public Setting<Integer> placeDelay = this.register(new Setting<Object>(\"PlaceDelay\", 25, 0, 500, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue()));\r\n    public Setting<Float> placeRange = this.register(new Setting<Object>(\"PlaceRange\", 6.0f, 0.0f, 10.0f, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue()));\r\n    public Setting<Float> minDamage = this.register(new Setting<Object>(\"MinDamage\", 7.0f, 0.1f, 20.0f, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue()));\r\n    public Setting<Float> maxSelfPlace = this.register(new Setting<Object>(\"MaxSelfPlace\", 10.0f, 0.1f, 36.0f, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue()));\r\n    public Setting<Integer> wasteAmount = this.register(new Setting<Object>(\"WasteAmount\", 2, 1, 5, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue()));\r\n    public Setting<Boolean> wasteMinDmgCount = this.register(new Setting<Object>(\"CountMinDmg\", Boolean.TRUE, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue()));\r\n    public Setting<Float> facePlace = this.register(new Setting<Object>(\"FacePlace\", 8.0f, 0.1f, 20.0f, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue()));\r\n    public Setting<Float> placetrace = this.register(new Setting<Object>(\"Placetrace\", 4.5f, 0.0f, 10.0f, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue() && this.raytrace.getValue() != Raytrace.NONE && this.raytrace.getValue() != Raytrace.BREAK));\r\n    public Setting<Boolean> antiSurround = this.register(new Setting<Object>(\"AntiSurround\", Boolean.TRUE, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue()));\r\n    public Setting<Boolean> limitFacePlace = this.register(new Setting<Object>(\"LimitFacePlace\", Boolean.TRUE, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue()));\r\n    public Setting<Boolean> oneDot15 = this.register(new Setting<Object>(\"1.15\", Boolean.FALSE, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue()));\r\n    public Setting<Boolean> doublePop = this.register(new Setting<Object>(\"AntiTotem\", Boolean.FALSE, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue()));\r\n    public Setting<Double> popHealth = this.register(new Setting<Object>(\"PopHealth\", 1.0, 0.0, 3.0, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue() && this.doublePop.getValue()));\r\n    public Setting<Float> popDamage = this.register(new Setting<Object>(\"PopDamage\", 4.0f, 0.0f, 6.0f, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue() && this.doublePop.getValue()));\r\n    public Setting<Integer> popTime = this.register(new Setting<Object>(\"PopTime\", 500, 0, 1000, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue() && this.doublePop.getValue()));\r\n    public Setting<Boolean> explode = this.register(new Setting<Object>(\"Break\", Boolean.TRUE, v -> this.setting.getValue() == Settings.BREAK));\r\n    public Setting<Switch> switchMode = this.register(new Setting<Object>(\"Attack\", Switch.BREAKSLOT, v -> this.setting.getValue() == Settings.BREAK && this.explode.getValue()));\r\n    public Setting<Integer> breakDelay = this.register(new Setting<Object>(\"BreakDelay\", 50, 0, 500, v -> this.setting.getValue() == Settings.BREAK && this.explode.getValue()));\r\n    public Setting<Float> breakRange = this.register(new Setting<Object>(\"BreakRange\", 6.0f, 0.0f, 10.0f, v -> this.setting.getValue() == Settings.BREAK && this.explode.getValue()));\r\n    public Setting<Integer> packets = this.register(new Setting<Object>(\"Packets\", 1, 1, 6, v -> this.setting.getValue() == Settings.BREAK && this.explode.getValue()));\r\n    public Setting<Float> maxSelfBreak = this.register(new Setting<Object>(\"MaxSelfBreak\", 10.0f, 0.1f, 36.0f, v -> this.setting.getValue() == Settings.BREAK && this.explode.getValue()));\r\n    public Setting<Float> breaktrace = this.register(new Setting<Object>(\"Breaktrace\", 4.5f, 0.0f, 10.0f, v -> this.setting.getValue() == Settings.BREAK && this.explode.getValue() && this.raytrace.getValue() != Raytrace.NONE && this.raytrace.getValue() != Raytrace.PLACE));\r\n    public Setting<Boolean> manual = this.register(new Setting<Object>(\"Manual\", Boolean.TRUE, v -> this.setting.getValue() == Settings.BREAK));\r\n    public Setting<Boolean> manualMinDmg = this.register(new Setting<Object>(\"ManMinDmg\", Boolean.TRUE, v -> this.setting.getValue() == Settings.BREAK && this.manual.getValue()));\r\n    public Setting<Integer> manualBreak = this.register(new Setting<Object>(\"ManualDelay\", 500, 0, 500, v -> this.setting.getValue() == Settings.BREAK && this.manual.getValue()));\r\n    public Setting<Boolean> sync = this.register(new Setting<Object>(\"Sync\", Boolean.TRUE, v -> this.setting.getValue() == Settings.BREAK && (this.explode.getValue() || this.manual.getValue())));\r\n    public Setting<Boolean> instant = this.register(new Setting<Object>(\"Predict\", Boolean.TRUE, v -> this.setting.getValue() == Settings.BREAK && this.explode.getValue() && this.place.getValue()));\r\n    public Setting<PredictTimer> instantTimer = this.register(new Setting<Object>(\"PredictTimer\", PredictTimer.NONE, v -> this.setting.getValue() == Settings.BREAK && this.explode.getValue() && this.place.getValue() && this.instant.getValue()));\r\n    public Setting<Boolean> resetBreakTimer = this.register(new Setting<Object>(\"ResetBreakTimer\", Boolean.TRUE, v -> this.setting.getValue() == Settings.BREAK && this.explode.getValue() && this.place.getValue() && this.instant.getValue()));\r\n    public Setting<Integer> predictDelay = this.register(new Setting<Object>(\"PredictDelay\", 12, 0, 500, v -> this.setting.getValue() == Settings.BREAK && this.explode.getValue() && this.place.getValue() && this.instant.getValue() && this.instantTimer.getValue() == PredictTimer.PREDICT));\r\n    public Setting<Boolean> predictCalc = this.register(new Setting<Object>(\"PredictCalc\", Boolean.TRUE, v -> this.setting.getValue() == Settings.BREAK && this.explode.getValue() && this.place.getValue() && this.instant.getValue()));\r\n    public Setting<Boolean> superSafe = this.register(new Setting<Object>(\"SuperSafe\", Boolean.TRUE, v -> this.setting.getValue() == Settings.BREAK && this.explode.getValue() && this.place.getValue() && this.instant.getValue()));\r\n    public Setting<Boolean> antiCommit = this.register(new Setting<Object>(\"AntiOverCommit\", Boolean.TRUE, v -> this.setting.getValue() == Settings.BREAK && this.explode.getValue() && this.place.getValue() && this.instant.getValue()));\r\n    public Setting<Boolean> render = this.register(new Setting<Object>(\"Render\", Boolean.TRUE, v -> this.setting.getValue() == Settings.RENDER));\r\n    private final Setting<Integer> red = this.register(new Setting<Object>(\"Red\", 255, 0, 255, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue()));\r\n    private final Setting<Integer> green = this.register(new Setting<Object>(\"Green\", 255, 0, 255, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue()));\r\n    private final Setting<Integer> blue = this.register(new Setting<Object>(\"Blue\", 255, 0, 255, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue()));\r\n    private final Setting<Integer> alpha = this.register(new Setting<Object>(\"Alpha\", 255, 0, 255, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue()));\r\n    public Setting<Boolean> colorSync = this.register(new Setting<Object>(\"ColorSync\", Boolean.FALSE, v -> this.setting.getValue() == Settings.RENDER));\r\n    public Setting<Boolean> box = this.register(new Setting<Object>(\"Box\", Boolean.TRUE, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue()));\r\n    private final Setting<Integer> boxAlpha = this.register(new Setting<Object>(\"BoxAlpha\", 125, 0, 255, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue() && this.box.getValue()));\r\n    public Setting<Boolean> outline = this.register(new Setting<Object>(\"Outline\", Boolean.TRUE, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue()));\r\n    private final Setting<Float> lineWidth = this.register(new Setting<Object>(\"LineWidth\", 1.5f, 0.1f, 5.0f, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue() && this.outline.getValue()));\r\n    public Setting<Boolean> text = this.register(new Setting<Object>(\"Text\", Boolean.FALSE, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue()));\r\n    public Setting<Boolean> customOutline = this.register(new Setting<Object>(\"CustomLine\", Boolean.FALSE, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue() && this.outline.getValue()));\r\n    private final Setting<Integer> cRed = this.register(new Setting<Object>(\"OL-Red\", 255, 0, 255, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue() && this.customOutline.getValue() && this.outline.getValue()));\r\n    private final Setting<Integer> cGreen = this.register(new Setting<Object>(\"OL-Green\", 255, 0, 255, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue() && this.customOutline.getValue() && this.outline.getValue()));\r\n    private final Setting<Integer> cBlue = this.register(new Setting<Object>(\"OL-Blue\", 255, 0, 255, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue() && this.customOutline.getValue() && this.outline.getValue()));\r\n    private final Setting<Integer> cAlpha = this.register(new Setting<Object>(\"OL-Alpha\", 255, 0, 255, v -> this.setting.getValue() == Settings.RENDER && this.render.getValue() && this.customOutline.getValue() && this.outline.getValue()));\r\n    public Setting<Boolean> holdFacePlace = this.register(new Setting<Object>(\"HoldFacePlace\", Boolean.FALSE, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Boolean> holdFaceBreak = this.register(new Setting<Object>(\"HoldSlowBreak\", Boolean.FALSE, v -> this.setting.getValue() == Settings.MISC && this.holdFacePlace.getValue()));\r\n    public Setting<Boolean> slowFaceBreak = this.register(new Setting<Object>(\"SlowFaceBreak\", Boolean.FALSE, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Boolean> actualSlowBreak = this.register(new Setting<Object>(\"ActuallySlow\", Boolean.FALSE, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Integer> facePlaceSpeed = this.register(new Setting<Object>(\"FaceSpeed\", 500, 0, 500, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Boolean> sequential = this.register(new Setting<Object>(\"Sequential\", true, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Boolean> cancelCrystal = this.register(new Setting<Object>(\"CancelCrystal\", true, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Boolean> antiNaked = this.register(new Setting<Object>(\"AntiNaked\", Boolean.FALSE, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Float> range = this.register(new Setting<Object>(\"Range\", 12.0f, 0.1f, 20.0f, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Target> targetMode = this.register(new Setting<Object>(\"Target\", Target.CLOSEST, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Integer> minArmor = this.register(new Setting<Object>(\"MinArmor\", 5, 0, 125, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<AutoSwitch> autoSwitch = this.register(new Setting<Object>(\"Switch\", AutoSwitch.TOGGLE, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Bind> switchBind = this.register(new Setting<Object>(\"SwitchBind\", new Bind(-1), v -> this.setting.getValue() == Settings.MISC && this.autoSwitch.getValue() == AutoSwitch.TOGGLE));\r\n    public Setting<Boolean> offhandSwitch = this.register(new Setting<Object>(\"Offhand\", Boolean.TRUE, v -> this.setting.getValue() == Settings.MISC && this.autoSwitch.getValue() != AutoSwitch.NONE));\r\n    public Setting<Boolean> switchBack = this.register(new Setting<Object>(\"Switchback\", Boolean.TRUE, v -> this.setting.getValue() == Settings.MISC && this.autoSwitch.getValue() != AutoSwitch.NONE && this.offhandSwitch.getValue()));\r\n    public Setting<Boolean> lethalSwitch = this.register(new Setting<Object>(\"LethalSwitch\", Boolean.FALSE, v -> this.setting.getValue() == Settings.MISC && this.autoSwitch.getValue() != AutoSwitch.NONE));\r\n    public Setting<Boolean> mineSwitch = this.register(new Setting<Object>(\"MineSwitch\", Boolean.TRUE, v -> this.setting.getValue() == Settings.MISC && this.autoSwitch.getValue() != AutoSwitch.NONE));\r\n    public Setting<Rotate> rotate = this.register(new Setting<Object>(\"Rotate\", Rotate.OFF, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Boolean> suicide = this.register(new Setting<Object>(\"Suicide\", Boolean.FALSE, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Boolean> webAttack = this.register(new Setting<Object>(\"WebAttack\", Boolean.TRUE, v -> this.setting.getValue() == Settings.MISC && this.targetMode.getValue() != Target.DAMAGE));\r\n    public Setting<Boolean> fullCalc = this.register(new Setting<Object>(\"ExtraCalc\", Boolean.FALSE, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Boolean> sound = this.register(new Setting<Object>(\"Sound\", Boolean.TRUE, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Float> soundPlayer = this.register(new Setting<Object>(\"SoundPlayer\", 6.0f, 0.0f, 12.0f, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Boolean> soundConfirm = this.register(new Setting<Object>(\"SoundConfirm\", Boolean.TRUE, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Boolean> extraSelfCalc = this.register(new Setting<Object>(\"MinSelfDmg\", Boolean.FALSE, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<AntiFriendPop> antiFriendPop = this.register(new Setting<Object>(\"FriendPop\", AntiFriendPop.NONE, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Boolean> noCount = this.register(new Setting<Object>(\"AntiCount\", Boolean.FALSE, v -> this.setting.getValue() == Settings.MISC && (this.antiFriendPop.getValue() == AntiFriendPop.ALL || this.antiFriendPop.getValue() == AntiFriendPop.BREAK)));\r\n    public Setting<Boolean> calcEvenIfNoDamage = this.register(new Setting<Object>(\"BigFriendCalc\", Boolean.FALSE, v -> this.setting.getValue() == Settings.MISC && (this.antiFriendPop.getValue() == AntiFriendPop.ALL || this.antiFriendPop.getValue() == AntiFriendPop.BREAK) && this.targetMode.getValue() != Target.DAMAGE));\r\n    public Setting<Boolean> predictFriendDmg = this.register(new Setting<Object>(\"PredictFriend\", Boolean.FALSE, v -> this.setting.getValue() == Settings.MISC && (this.antiFriendPop.getValue() == AntiFriendPop.ALL || this.antiFriendPop.getValue() == AntiFriendPop.BREAK) && this.instant.getValue()));\r\n    public Setting<Float> minMinDmg = this.register(new Setting<Object>(\"MinMinDmg\", 0.0f, 0.0f, 3.0f, v -> this.setting.getValue() == Settings.DEV && this.place.getValue()));\r\n    public Setting<Boolean> breakSwing = this.register(new Setting<Object>(\"BreakSwing\", Boolean.TRUE, v -> this.setting.getValue() == Settings.DEV));\r\n    public Setting<Boolean> placeSwing = this.register(new Setting<Object>(\"PlaceSwing\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV));\r\n    public Setting<Boolean> exactHand = this.register(new Setting<Object>(\"ExactHand\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV && this.placeSwing.getValue()));\r\n    public Setting<Boolean> justRender = this.register(new Setting<Object>(\"JustRender\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV));\r\n    public Setting<Logic> logic = this.register(new Setting<Object>(\"Logic\", Logic.BREAKPLACE, v -> this.setting.getValue() == Settings.DEV));\r\n    public Setting<DamageSync> damageSync = this.register(new Setting<Object>(\"DamageSync\", DamageSync.NONE, v -> this.setting.getValue() == Settings.DEV));\r\n    public Setting<Integer> damageSyncTime = this.register(new Setting<Object>(\"SyncDelay\", 500, 0, 500, v -> this.setting.getValue() == Settings.DEV && this.damageSync.getValue() != DamageSync.NONE));\r\n    public Setting<Float> dropOff = this.register(new Setting<Object>(\"DropOff\", 5.0f, 0.0f, 10.0f, v -> this.setting.getValue() == Settings.DEV && this.damageSync.getValue() == DamageSync.BREAK));\r\n    public Setting<Integer> confirm = this.register(new Setting<Object>(\"Confirm\", 250, 0, 1000, v -> this.setting.getValue() == Settings.DEV && this.damageSync.getValue() != DamageSync.NONE));\r\n    public Setting<Boolean> syncedFeetPlace = this.register(new Setting<Object>(\"FeetSync\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV && this.damageSync.getValue() != DamageSync.NONE));\r\n    public Setting<Boolean> fullSync = this.register(new Setting<Object>(\"FullSync\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV && this.damageSync.getValue() != DamageSync.NONE && this.syncedFeetPlace.getValue()));\r\n    public Setting<Boolean> syncCount = this.register(new Setting<Object>(\"SyncCount\", Boolean.TRUE, v -> this.setting.getValue() == Settings.DEV && this.damageSync.getValue() != DamageSync.NONE && this.syncedFeetPlace.getValue()));\r\n    public Setting<Boolean> hyperSync = this.register(new Setting<Object>(\"HyperSync\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV && this.damageSync.getValue() != DamageSync.NONE && this.syncedFeetPlace.getValue()));\r\n    public Setting<Boolean> gigaSync = this.register(new Setting<Object>(\"GigaSync\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV && this.damageSync.getValue() != DamageSync.NONE && this.syncedFeetPlace.getValue()));\r\n    public Setting<Boolean> syncySync = this.register(new Setting<Object>(\"SyncySync\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV && this.damageSync.getValue() != DamageSync.NONE && this.syncedFeetPlace.getValue()));\r\n    public Setting<Boolean> enormousSync = this.register(new Setting<Object>(\"EnormousSync\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV && this.damageSync.getValue() != DamageSync.NONE && this.syncedFeetPlace.getValue()));\r\n    public Setting<Boolean> holySync = this.register(new Setting<Object>(\"UnbelievableSync\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV && this.damageSync.getValue() != DamageSync.NONE && this.syncedFeetPlace.getValue()));\r\n    public Setting<Boolean> rotateFirst = this.register(new Setting<Object>(\"FirstRotation\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV && this.rotate.getValue() != Rotate.OFF && this.eventMode.getValue() == 2));\r\n    public Setting<ThreadMode> threadMode = this.register(new Setting<Object>(\"Thread\", ThreadMode.NONE, v -> this.setting.getValue() == Settings.DEV));\r\n    public Setting<Integer> threadDelay = this.register(new Setting<Object>(\"ThreadDelay\", 50, 1, 1000, v -> this.setting.getValue() == Settings.DEV && this.threadMode.getValue() != ThreadMode.NONE));\r\n    public Setting<Boolean> syncThreadBool = this.register(new Setting<Object>(\"ThreadSync\", Boolean.TRUE, v -> this.setting.getValue() == Settings.DEV && this.threadMode.getValue() != ThreadMode.NONE));\r\n    public Setting<Integer> syncThreads = this.register(new Setting<Object>(\"SyncThreads\", 1000, 1, 10000, v -> this.setting.getValue() == Settings.DEV && this.threadMode.getValue() != ThreadMode.NONE && this.syncThreadBool.getValue()));\r\n    public Setting<Boolean> predictPos = this.register(new Setting<Object>(\"PredictPos\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV));\r\n    public Setting<Boolean> renderExtrapolation = this.register(new Setting<Object>(\"RenderExtrapolation\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV && this.predictPos.getValue()));\r\n    public Setting<Integer> predictTicks = this.register(new Setting<Object>(\"ExtrapolationTicks\", 2, 1, 20, v -> this.setting.getValue() == Settings.DEV && this.predictPos.getValue()));\r\n    public Setting<Integer> rotations = this.register(new Setting<Object>(\"Spoofs\", 1, 1, 20, v -> this.setting.getValue() == Settings.DEV));\r\n    public Setting<Boolean> predictRotate = this.register(new Setting<Object>(\"PredictRotate\", Boolean.FALSE, v -> this.setting.getValue() == Settings.DEV));\r\n    public Setting<Float> predictOffset = this.register(new Setting<Object>(\"PredictOffset\", 0.0f, 0.0f, 4.0f, v -> this.setting.getValue() == Settings.DEV));\r\n    public Setting<Boolean> brownZombie = this.register(new Setting<Object>(\"BrownZombieMode\", Boolean.FALSE, v -> this.setting.getValue() == Settings.MISC));\r\n    public Setting<Boolean> doublePopOnDamage = this.register(new Setting<Object>(\"DamagePop\", Boolean.FALSE, v -> this.setting.getValue() == Settings.PLACE && this.place.getValue() && this.doublePop.getValue() && this.targetMode.getValue() == Target.DAMAGE));\r\n    public boolean rotating = false;\r\n    private Queue<Entity> attackList = new ConcurrentLinkedQueue<>();\r\n    private Map<Entity, Float> crystalMap = new HashMap<>();\r\n    private Entity efficientTarget = null;\r\n    private double currentDamage = 0.0;\r\n    private double renderDamage = 0.0;\r\n    private double lastDamage = 0.0;\r\n    private boolean didRotation = false;\r\n    private boolean switching = false;\r\n    private BlockPos placePos = null;\r\n    private BlockPos renderPos = null;\r\n    private boolean mainHand = false;\r\n    private boolean offHand = false;\r\n    private int crystalCount = 0;\r\n    private int minDmgCount = 0;\r\n    private int lastSlot = -1;\r\n    private float yaw = 0.0f;\r\n    private float pitch = 0.0f;\r\n    private BlockPos webPos = null;\r\n    private BlockPos lastPos = null;\r\n    private boolean posConfirmed = false;\r\n    private boolean foundDoublePop = false;\r\n    private int rotationPacketsSpoofed = 0;\r\n    private ScheduledExecutorService executor;\r\n    private Thread thread;\r\n    private EntityPlayer currentSyncTarget;\r\n    private BlockPos syncedPlayerPos;\r\n    private BlockPos syncedCrystalPos;\r\n    private PlaceInfo placeInfo;\r\n    private boolean addTolowDmg;\r\n    private Object BlockPos;\r\n\r\n    public AutoCrystal() {\r\n        super(\"AutoCrystal\", \"Best CA on the market\", Category.COMBAT, true, false, false);\r\n        instance = this;\r\n    }\r\n\r\n    public static AutoCrystal getInstance() {\r\n        if (instance == null) {\r\n            instance = new AutoCrystal();\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    @Override\r\n    public void onTick() {\r\n        if (this.threadMode.getValue() == ThreadMode.NONE && this.eventMode.getValue() == 3) {\r\n            this.doAutoCrystal();\r\n        }\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public void onUpdateWalkingPlayer(UpdateWalkingPlayerEvent event) {\r\n        if (event.getStage() == 1) {\r\n            this.postProcessing();\r\n        }\r\n        if (event.getStage() != 0) {\r\n            return;\r\n        }\r\n        if (this.eventMode.getValue() == 2) {\r\n            this.doAutoCrystal();\r\n        }\r\n    }\r\n\r\n    public void postTick() {\r\n        if (this.threadMode.getValue() != ThreadMode.NONE) {\r\n            this.processMultiThreading();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onUpdate() {\r\n        if (this.threadMode.getValue() == ThreadMode.NONE && this.eventMode.getValue() == 1) {\r\n            this.doAutoCrystal();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onToggle() {\r\n        brokenPos.clear();\r\n        placedPos.clear();\r\n        this.totemPops.clear();\r\n        this.rotating = false;\r\n    }\r\n\r\n    @Override\r\n    public void onDisable() {\r\n        if (this.thread != null) {\r\n            this.shouldInterrupt.set(true);\r\n        }\r\n        if (this.executor != null) {\r\n            this.executor.shutdown();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onEnable() {\r\n        if (this.threadMode.getValue() != ThreadMode.NONE) {\r\n            this.processMultiThreading();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String getDisplayInfo() {\r\n        if (this.switching) {\r\n            return \"\\u00a7aSwitch\";\r\n        }\r\n        if (target != null) {\r\n            return target.getName();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public void onPacketSend(PacketEvent.Send event) {\r\n        CPacketUseEntity packet;\r\n        if (event.getStage() == 0 && this.rotate.getValue() != Rotate.OFF && this.rotating && this.eventMode.getValue() != 2 && event.getPacket() instanceof CPacketPlayer) {\r\n            CPacketPlayer packet2 = event.getPacket();\r\n            packet2.yaw = this.yaw;\r\n            packet2.pitch = this.pitch;\r\n            ++this.rotationPacketsSpoofed;\r\n            if (this.rotationPacketsSpoofed >= this.rotations.getValue()) {\r\n                this.rotating = false;\r\n                this.rotationPacketsSpoofed = 0;\r\n            }\r\n        }\r\n        BlockPos pos = null;\r\n        if (event.getStage() == 0 && event.getPacket() instanceof CPacketUseEntity && (packet = event.getPacket()).getAction() == CPacketUseEntity.Action.ATTACK && packet.getEntityFromWorld(AutoCrystal.mc.world) instanceof EntityEnderCrystal) {\r\n            pos = Objects.requireNonNull(packet.getEntityFromWorld(AutoCrystal.mc.world)).getPosition();\r\n            if (this.removeAfterAttack.getValue()) {\r\n                Objects.requireNonNull(packet.getEntityFromWorld(AutoCrystal.mc.world)).setDead();\r\n                AutoCrystal.mc.world.removeEntityFromWorld(packet.entityId);\r\n            }\r\n        }\r\n        if (event.getStage() == 0 && event.getPacket() instanceof CPacketUseEntity && (packet = event.getPacket()).getAction() == CPacketUseEntity.Action.ATTACK && packet.getEntityFromWorld(AutoCrystal.mc.world) instanceof EntityEnderCrystal) {\r\n            EntityEnderCrystal crystal = (EntityEnderCrystal) packet.getEntityFromWorld(AutoCrystal.mc.world);\r\n            if (this.antiBlock.getValue() && EntityUtil.isCrystalAtFeet(crystal, this.range.getValue()) && pos != null) {\r\n                this.rotateToPos(pos);\r\n                BlockUtil.placeCrystalOnBlock(this.placePos, this.offHand ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND, this.placeSwing.getValue(), this.exactHand.getValue());\r\n            }\r\n        }\r\n        if (event.getStage() == 0 && event.getPacket() instanceof CPacketUseEntity && (packet = event.getPacket()).getAction() == CPacketUseEntity.Action.ATTACK && packet.getEntityFromWorld(AutoCrystal.mc.world) instanceof EntityEnderCrystal && this.cancelCrystal.getValue()) {\r\n            Objects.requireNonNull(packet.getEntityFromWorld(AutoCrystal.mc.world)).setDead();\r\n            AutoCrystal.mc.world.removeEntityFromWorld(packet.entityId);\r\n        }\r\n    }\r\n\r\n    @SubscribeEvent(priority = EventPriority.HIGH, receiveCanceled = true)\r\n    public void onSoundPacket(PacketEvent.Receive event) {\r\n        if (AutoCrystal.fullNullCheck()) {\r\n            return;\r\n        }\r\n        if (event.getPacket() instanceof SPacketSoundEffect && this.sequential.getValue()) {\r\n            final SPacketSoundEffect packet2 = event.getPacket();\r\n            if (packet2.getCategory() == SoundCategory.BLOCKS && packet2.getSound() == SoundEvents.ENTITY_GENERIC_EXPLODE) {\r\n                final List<Entity> entities = new ArrayList<>(this.mc.world.loadedEntityList);\r\n                for (int size = entities.size(), i = 0; i < size; ++i) {\r\n                    final Entity entity = entities.get(i);\r\n                    if (entity instanceof EntityEnderCrystal && entity.getDistanceSq(packet2.getX(), packet2.getY(), packet2.getZ()) < 36.0) {\r\n                        entity.setDead();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @SubscribeEvent(priority = EventPriority.HIGH, receiveCanceled = true)\r\n    public void onPacketReceive(PacketEvent.Receive event) {\r\n        SPacketSoundEffect packet;\r\n        if (AutoCrystal.fullNullCheck()) {\r\n            return;\r\n        }\r\n        if (!this.justRender.getValue() && this.switchTimer.passedMs(this.switchCooldown.getValue()) && this.explode.getValue() && this.instant.getValue() && event.getPacket() instanceof SPacketSpawnObject && (this.syncedCrystalPos == null || !this.syncedFeetPlace.getValue() || this.damageSync.getValue() == DamageSync.NONE)) {\r\n            BlockPos pos;\r\n            SPacketSpawnObject packet2 = event.getPacket();\r\n            if (packet2.getType() == 51 && AutoCrystal.mc.player.getDistanceSq(pos = new BlockPos(packet2.getX(), packet2.getY(), packet2.getZ())) + (double) this.predictOffset.getValue() <= MathUtil.square(this.breakRange.getValue()) && (this.instantTimer.getValue() == PredictTimer.NONE || this.instantTimer.getValue() == PredictTimer.BREAK && this.breakTimer.passedMs(this.breakDelay.getValue()) || this.instantTimer.getValue() == PredictTimer.PREDICT && this.predictTimer.passedMs(this.predictDelay.getValue()))) {\r\n                if (this.predictSlowBreak(pos.down())) {\r\n                    return;\r\n                }\r\n                if (this.predictFriendDmg.getValue() && (this.antiFriendPop.getValue() == AntiFriendPop.BREAK || this.antiFriendPop.getValue() == AntiFriendPop.ALL) && this.isRightThread()) {\r\n                    for (EntityPlayer friend : AutoCrystal.mc.world.playerEntities) {\r\n                        if (friend == null || AutoCrystal.mc.player.equals(friend) || friend.getDistanceSq(pos) > MathUtil.square(this.range.getValue() + this.placeRange.getValue()) || !Quantum.friendManager.isFriend(friend) || !((double) DamageUtil.calculateDamage(pos, friend) > (double) EntityUtil.getHealth(friend) + 0.5))\r\n                            continue;\r\n                        return;\r\n                    }\r\n                }\r\n                if (placedPos.contains(pos.down())) {\r\n                    float selfDamage;\r\n                    if (this.isRightThread() && this.superSafe.getValue() ? DamageUtil.canTakeDamage(this.suicide.getValue()) && ((double) (selfDamage = DamageUtil.calculateDamage(pos, AutoCrystal.mc.player)) - 0.5 > (double) EntityUtil.getHealth(AutoCrystal.mc.player) || selfDamage > this.maxSelfBreak.getValue()) : this.superSafe.getValue()) {\r\n                        return;\r\n                    }\r\n                    this.attackCrystalPredict(packet2.getEntityID(), pos);\r\n                } else if (this.predictCalc.getValue() && this.isRightThread()) {\r\n                    float selfDamage = -1.0f;\r\n                    if (DamageUtil.canTakeDamage(this.suicide.getValue())) {\r\n                        selfDamage = DamageUtil.calculateDamage(pos, AutoCrystal.mc.player);\r\n                    }\r\n                    if ((double) selfDamage + 0.5 < (double) EntityUtil.getHealth(AutoCrystal.mc.player) && selfDamage <= this.maxSelfBreak.getValue()) {\r\n                        for (EntityPlayer player : AutoCrystal.mc.world.playerEntities) {\r\n                            float damage;\r\n                            if (!(player.getDistanceSq(pos) <= MathUtil.square(this.range.getValue())) || !EntityUtil.isValid(player, this.range.getValue() + this.breakRange.getValue()) || this.antiNaked.getValue() && DamageUtil.isNaked(player) || !((damage = DamageUtil.calculateDamage(pos, player)) > selfDamage || damage > this.minDamage.getValue() && !DamageUtil.canTakeDamage(this.suicide.getValue())) && !(damage > EntityUtil.getHealth(player)))\r\n                                continue;\r\n                            if (this.predictRotate.getValue() && this.eventMode.getValue() != 2 && (this.rotate.getValue() == Rotate.BREAK || this.rotate.getValue() == Rotate.ALL)) {\r\n                                this.rotateToPos(pos);\r\n                            }\r\n                            this.attackCrystalPredict(packet2.getEntityID(), pos);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (!this.soundConfirm.getValue() && event.getPacket() instanceof SPacketExplosion) {\r\n            SPacketExplosion packet3 = event.getPacket();\r\n            BlockPos pos = new BlockPos(packet3.getX(), packet3.getY(), packet3.getZ()).down();\r\n            this.removePos(pos);\r\n        } else if (event.getPacket() instanceof SPacketDestroyEntities) {\r\n            SPacketDestroyEntities packet4 = event.getPacket();\r\n            for (int id : packet4.getEntityIDs()) {\r\n                Entity entity = AutoCrystal.mc.world.getEntityByID(id);\r\n                if (!(entity instanceof EntityEnderCrystal)) continue;\r\n                brokenPos.remove(new BlockPos(entity.getPositionVector()).down());\r\n                placedPos.remove(new BlockPos(entity.getPositionVector()).down());\r\n            }\r\n        } else if (event.getPacket() instanceof SPacketEntityStatus) {\r\n            SPacketEntityStatus packet5 = event.getPacket();\r\n            if (packet5.getOpCode() == 35 && packet5.getEntity(AutoCrystal.mc.world) instanceof EntityPlayer) {\r\n                this.totemPops.put((EntityPlayer) packet5.getEntity(AutoCrystal.mc.world), new me.derp.quantum.util.Timer().reset());\r\n            }\r\n        } else if (event.getPacket() instanceof SPacketSoundEffect && (packet = event.getPacket()).getCategory() == SoundCategory.BLOCKS && packet.getSound() == SoundEvents.ENTITY_GENERIC_EXPLODE) {\r\n            BlockPos pos = new BlockPos(packet.getX(), packet.getY(), packet.getZ());\r\n            if (this.soundConfirm.getValue()) {\r\n                this.removePos(pos);\r\n            }\r\n            if (this.threadMode.getValue() == ThreadMode.SOUND && this.isRightThread() && AutoCrystal.mc.player != null && AutoCrystal.mc.player.getDistanceSq(pos) < MathUtil.square(this.soundPlayer.getValue())) {\r\n                this.handlePool(true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private boolean predictSlowBreak(BlockPos pos) {\r\n        if (this.antiCommit.getValue() && lowDmgPos.remove(pos)) {\r\n            return this.shouldSlowBreak(false);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private boolean isRightThread() {\r\n        return mc.isCallingFromMinecraftThread() || !Quantum.eventManager.ticksOngoing() && !this.threadOngoing.get();\r\n    }\r\n\r\n    private void attackCrystalPredict(int entityID, BlockPos pos) {\r\n        if (!(!this.predictRotate.getValue() || this.eventMode.getValue() == 2 && this.threadMode.getValue() == ThreadMode.NONE || this.rotate.getValue() != Rotate.BREAK && this.rotate.getValue() != Rotate.ALL)) {\r\n            this.rotateToPos(pos);\r\n        }\r\n        CPacketUseEntity attackPacket = new CPacketUseEntity();\r\n        attackPacket.entityId = entityID;\r\n        attackPacket.action = CPacketUseEntity.Action.ATTACK;\r\n        AutoCrystal.mc.player.connection.sendPacket(attackPacket);\r\n        if (this.breakSwing.getValue()) {\r\n            AutoCrystal.mc.player.connection.sendPacket(new CPacketAnimation(EnumHand.MAIN_HAND));\r\n        }\r\n        if (this.resetBreakTimer.getValue()) {\r\n            this.breakTimer.reset();\r\n        }\r\n        this.predictTimer.reset();\r\n    }\r\n\r\n    private void removePos(BlockPos pos) {\r\n        if (this.damageSync.getValue() == DamageSync.PLACE) {\r\n            if (placedPos.remove(pos)) {\r\n                this.posConfirmed = true;\r\n            }\r\n        } else if (this.damageSync.getValue() == DamageSync.BREAK && brokenPos.remove(pos)) {\r\n            this.posConfirmed = true;\r\n        }\r\n    }\r\n\r\n    public void onRender3D(Render3DEvent event) {\r\n        if ((this.offHand || this.mainHand || this.switchMode.getValue() == Switch.CALC) && this.renderPos != null && this.render.getValue() && (this.box.getValue() || this.text.getValue() || this.outline.getValue())) {\r\n            RenderUtil.drawBoxESP(this.renderPos, this.colorSync.getValue() ? ColorUtil.rainbow(ClickGui.getInstance().rainbowHue.getValue()) : new Color(this.red.getValue(), this.green.getValue(), this.blue.getValue(), this.alpha.getValue()), this.customOutline.getValue(), this.colorSync.getValue() ? getCurrentColor() : new Color(this.cRed.getValue(), this.cGreen.getValue(), this.cBlue.getValue(), this.cAlpha.getValue()), this.lineWidth.getValue(), this.outline.getValue(), this.box.getValue(), this.boxAlpha.getValue(), false);\r\n            if (this.text.getValue()) {\r\n                RenderUtil.drawText(this.renderPos, (Math.floor(this.renderDamage) == this.renderDamage ? Integer.valueOf((int) this.renderDamage) : String.format(\"%.1f\", this.renderDamage)) + \"\");\r\n            }\r\n        }\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public void onKeyInput(InputEvent.KeyInputEvent event) {\r\n        if (Keyboard.getEventKeyState() && !(AutoCrystal.mc.currentScreen instanceof OyVeyGui) && this.switchBind.getValue().getKey() == Keyboard.getEventKey()) {\r\n            if (this.switchBack.getValue() && this.offhandSwitch.getValue() && this.offHand) {\r\n                Offhand module = Quantum.moduleManager.getModuleByClass(Offhand.class);\r\n                if (module.isOff()) {\r\n                    Command.sendMessage(\"<\" + this.getDisplayName() + \"> \" + \"\\u00a7c\" + \"Switch failed. Enable the Offhand module.\");\r\n                } else {\r\n                    module.setMode(Offhand.Mode2.TOTEMS);\r\n                    module.doSwitch();\r\n                }\r\n                return;\r\n            }\r\n            this.switching = !this.switching;\r\n        }\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public void onSettingChange(ClientEvent event) {\r\n        if (event.getStage() == 2 && event.getSetting() != null && event.getSetting().getFeature() != null && event.getSetting().getFeature().equals(this) && this.isEnabled() && (event.getSetting().equals(this.threadDelay) || event.getSetting().equals(this.threadMode))) {\r\n            if (this.executor != null) {\r\n                this.executor.shutdown();\r\n            }\r\n            if (this.thread != null) {\r\n                this.shouldInterrupt.set(true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void postProcessing() {\r\n        if (this.threadMode.getValue() != ThreadMode.NONE || this.eventMode.getValue() != 2 || this.rotate.getValue() == Rotate.OFF || !this.rotateFirst.getValue()) {\r\n            return;\r\n        }\r\n        switch (this.logic.getValue()) {\r\n            case BREAKPLACE: {\r\n                this.postProcessBreak();\r\n                this.postProcessPlace();\r\n                break;\r\n            }\r\n            case PLACEBREAK: {\r\n                this.postProcessPlace();\r\n                this.postProcessBreak();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private void postProcessBreak() {\r\n        while (!this.packetUseEntities.isEmpty()) {\r\n            CPacketUseEntity packet = this.packetUseEntities.poll();\r\n            AutoCrystal.mc.player.connection.sendPacket(packet);\r\n            if (this.breakSwing.getValue()) {\r\n                AutoCrystal.mc.player.swingArm(EnumHand.MAIN_HAND);\r\n            }\r\n            this.breakTimer.reset();\r\n        }\r\n    }\r\n\r\n    private void postProcessPlace() {\r\n        if (this.placeInfo != null) {\r\n            this.placeInfo.runPlace();\r\n            this.placeTimer.reset();\r\n            this.placeInfo = null;\r\n        }\r\n    }\r\n\r\n    private void processMultiThreading() {\r\n        if (this.isOff()) {\r\n            return;\r\n        }\r\n        if (this.threadMode.getValue() == ThreadMode.WHILE) {\r\n            this.handleWhile();\r\n        } else if (this.threadMode.getValue() != ThreadMode.NONE) {\r\n            this.handlePool(false);\r\n        }\r\n    }\r\n\r\n    private void handlePool(boolean justDoIt) {\r\n        if (justDoIt || this.executor == null || this.executor.isTerminated() || this.executor.isShutdown() || this.syncroTimer.passedMs(this.syncThreads.getValue()) && this.syncThreadBool.getValue()) {\r\n            if (this.executor != null) {\r\n                this.executor.shutdown();\r\n            }\r\n            this.executor = this.getExecutor();\r\n            this.syncroTimer.reset();\r\n        }\r\n    }\r\n\r\n    private void handleWhile() {\r\n        if (this.thread == null || this.thread.isInterrupted() || !this.thread.isAlive() || this.syncroTimer.passedMs(this.syncThreads.getValue()) && this.syncThreadBool.getValue()) {\r\n            if (this.thread == null) {\r\n                this.thread = new Thread(RAutoCrystal.getInstance(this));\r\n            } else if (this.syncroTimer.passedMs(this.syncThreads.getValue()) && !this.shouldInterrupt.get() && this.syncThreadBool.getValue()) {\r\n                this.shouldInterrupt.set(true);\r\n                this.syncroTimer.reset();\r\n                return;\r\n            }\r\n            if (this.thread != null && (this.thread.isInterrupted() || !this.thread.isAlive())) {\r\n                this.thread = new Thread(RAutoCrystal.getInstance(this));\r\n            }\r\n            if (this.thread != null && this.thread.getState() == Thread.State.NEW) {\r\n                try {\r\n                    this.thread.start();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n                this.syncroTimer.reset();\r\n            }\r\n        }\r\n    }\r\n\r\n    private ScheduledExecutorService getExecutor() {\r\n        ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();\r\n        service.scheduleAtFixedRate(RAutoCrystal.getInstance(this), 0L, this.threadDelay.getValue(), TimeUnit.MILLISECONDS);\r\n        return service;\r\n    }\r\n\r\n    public void doAutoCrystal() {\r\n        if (this.brownZombie.getValue()) {\r\n            return;\r\n        }\r\n        if (this.check()) {\r\n            switch (this.logic.getValue()) {\r\n                case PLACEBREAK: {\r\n                    this.placeCrystal();\r\n                    this.breakCrystal();\r\n                    break;\r\n                }\r\n                case BREAKPLACE: {\r\n                    this.breakCrystal();\r\n                    this.placeCrystal();\r\n                    break;\r\n                }\r\n            }\r\n            this.manualBreaker();\r\n        }\r\n    }\r\n\r\n    private boolean check() {\r\n        if (AutoCrystal.fullNullCheck()) {\r\n            return false;\r\n        }\r\n        if (this.syncTimer.passedMs(this.damageSyncTime.getValue())) {\r\n            this.currentSyncTarget = null;\r\n            this.syncedCrystalPos = null;\r\n            this.syncedPlayerPos = null;\r\n        } else if (this.syncySync.getValue() && this.syncedCrystalPos != null) {\r\n            this.posConfirmed = true;\r\n        }\r\n        this.foundDoublePop = false;\r\n        if (this.renderTimer.passedMs(500L)) {\r\n            this.renderPos = null;\r\n            this.renderTimer.reset();\r\n        }\r\n        this.mainHand = AutoCrystal.mc.player.getHeldItemMainhand().getItem() == Items.END_CRYSTAL;\r\n        this.offHand = AutoCrystal.mc.player.getHeldItemOffhand().getItem() == Items.END_CRYSTAL;\r\n        this.currentDamage = 0.0;\r\n        this.placePos = null;\r\n        if (this.lastSlot != AutoCrystal.mc.player.inventory.currentItem || AutoTrap.isPlacing || Surround.isPlacing) {\r\n            this.lastSlot = AutoCrystal.mc.player.inventory.currentItem;\r\n            this.switchTimer.reset();\r\n        }\r\n        if (!this.offHand && !this.mainHand) {\r\n            this.placeInfo = null;\r\n            this.packetUseEntities.clear();\r\n        }\r\n        if (this.offHand || this.mainHand) {\r\n            this.switching = false;\r\n        }\r\n        if (!((this.offHand || this.mainHand || this.switchMode.getValue() != Switch.BREAKSLOT || this.switching) && DamageUtil.canBreakWeakness(AutoCrystal.mc.player) && this.switchTimer.passedMs(this.switchCooldown.getValue()))) {\r\n            this.renderPos = null;\r\n            target = null;\r\n            this.rotating = false;\r\n            return false;\r\n        }\r\n        if (this.mineSwitch.getValue() && Mouse.isButtonDown(0) && (this.switching || this.autoSwitch.getValue() == AutoSwitch.ALWAYS) && Mouse.isButtonDown(1) && AutoCrystal.mc.player.getHeldItemMainhand().getItem() instanceof ItemPickaxe) {\r\n            this.switchItem();\r\n        }\r\n        this.mapCrystals();\r\n        if (!this.posConfirmed && this.damageSync.getValue() != DamageSync.NONE && this.syncTimer.passedMs(this.confirm.getValue())) {\r\n            this.syncTimer.setMs(this.damageSyncTime.getValue() + 1);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private void mapCrystals() {\r\n        this.efficientTarget = null;\r\n        if (this.packets.getValue() != 1) {\r\n            this.attackList = new ConcurrentLinkedQueue<>();\r\n            this.crystalMap = new HashMap<>();\r\n        }\r\n        this.crystalCount = 0;\r\n        this.minDmgCount = 0;\r\n        Entity maxCrystal = null;\r\n        float maxDamage = 0.5f;\r\n        for (Entity entity : AutoCrystal.mc.world.loadedEntityList) {\r\n            if (entity.isDead || !(entity instanceof EntityEnderCrystal) || !this.isValid(entity)) continue;\r\n            if (this.syncedFeetPlace.getValue() && entity.getPosition().down().equals(this.syncedCrystalPos) && this.damageSync.getValue() != DamageSync.NONE) {\r\n                ++this.minDmgCount;\r\n                ++this.crystalCount;\r\n                if (this.syncCount.getValue()) {\r\n                    this.minDmgCount = this.wasteAmount.getValue() + 1;\r\n                    this.crystalCount = this.wasteAmount.getValue() + 1;\r\n                }\r\n                if (!this.hyperSync.getValue()) continue;\r\n                maxCrystal = null;\r\n                break;\r\n            }\r\n            boolean count = false;\r\n            boolean countMin = false;\r\n            float selfDamage = -1.0f;\r\n            if (DamageUtil.canTakeDamage(this.suicide.getValue())) {\r\n                selfDamage = DamageUtil.calculateDamage(entity, AutoCrystal.mc.player);\r\n            }\r\n            if ((double) selfDamage + 0.5 < (double) EntityUtil.getHealth(AutoCrystal.mc.player) && selfDamage <= this.maxSelfBreak.getValue()) {\r\n                Entity beforeCrystal = maxCrystal;\r\n                float beforeDamage = maxDamage;\r\n                for (EntityPlayer player : AutoCrystal.mc.world.playerEntities) {\r\n                    float damage;\r\n                    if (!(player.getDistanceSq(entity) <= MathUtil.square(this.range.getValue())))\r\n                        continue;\r\n                    if (EntityUtil.isValid(player, this.range.getValue() + this.breakRange.getValue())) {\r\n                        if (this.antiNaked.getValue() && DamageUtil.isNaked(player) || !((damage = DamageUtil.calculateDamage(entity, player)) > selfDamage || damage > this.minDamage.getValue() && DamageUtil.canTakeDamage(this.suicide.getValue())) && !(damage > EntityUtil.getHealth(player)))\r\n                            continue;\r\n                        if (damage > maxDamage) {\r\n                            maxDamage = damage;\r\n                            maxCrystal = entity;\r\n                        }\r\n                        if (this.packets.getValue() == 1) {\r\n                            if (damage >= this.minDamage.getValue() || !this.wasteMinDmgCount.getValue()) {\r\n                                count = true;\r\n                            }\r\n                            countMin = true;\r\n                            continue;\r\n                        }\r\n                        if (this.crystalMap.get(entity) != null && !(this.crystalMap.get(entity) < damage))\r\n                            continue;\r\n                        this.crystalMap.put(entity, damage);\r\n                        continue;\r\n                    }\r\n                    if (this.antiFriendPop.getValue() != AntiFriendPop.BREAK && this.antiFriendPop.getValue() != AntiFriendPop.ALL || !Quantum.friendManager.isFriend(player.getName()) || !((double) (damage = DamageUtil.calculateDamage(entity, player)) > (double) EntityUtil.getHealth(player) + 0.5))\r\n                        continue;\r\n                    maxCrystal = beforeCrystal;\r\n                    maxDamage = beforeDamage;\r\n                    this.crystalMap.remove(entity);\r\n                    if (!this.noCount.getValue()) break;\r\n                    count = false;\r\n                    countMin = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!countMin) continue;\r\n            ++this.minDmgCount;\r\n            if (!count) continue;\r\n            ++this.crystalCount;\r\n        }\r\n        if (this.damageSync.getValue() == DamageSync.BREAK && ((double) maxDamage > this.lastDamage || this.syncTimer.passedMs(this.damageSyncTime.getValue()) || this.damageSync.getValue() == DamageSync.NONE)) {\r\n            this.lastDamage = maxDamage;\r\n        }\r\n        if (this.enormousSync.getValue() && this.syncedFeetPlace.getValue() && this.damageSync.getValue() != DamageSync.NONE && this.syncedCrystalPos != null) {\r\n            if (this.syncCount.getValue()) {\r\n                this.minDmgCount = this.wasteAmount.getValue() + 1;\r\n                this.crystalCount = this.wasteAmount.getValue() + 1;\r\n            }\r\n            return;\r\n        }\r\n        if (this.webAttack.getValue() && this.webPos != null) {\r\n            if (AutoCrystal.mc.player.getDistanceSq(this.webPos.up()) > MathUtil.square(this.breakRange.getValue())) {\r\n                this.webPos = null;\r\n            } else {\r\n                for (Entity entity : AutoCrystal.mc.world.getEntitiesWithinAABB(Entity.class, new AxisAlignedBB(this.webPos.up()))) {\r\n                    if (!(entity instanceof EntityEnderCrystal)) continue;\r\n                    this.attackList.add(entity);\r\n                    this.efficientTarget = entity;\r\n                    this.webPos = null;\r\n                    this.lastDamage = 0.5;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        if (this.shouldSlowBreak(true) && maxDamage < this.minDamage.getValue() && (target == null || !(EntityUtil.getHealth(target) <= this.facePlace.getValue()) || !this.breakTimer.passedMs(this.facePlaceSpeed.getValue()) && this.slowFaceBreak.getValue() && Mouse.isButtonDown(0) && this.holdFacePlace.getValue() && this.holdFaceBreak.getValue())) {\r\n            this.efficientTarget = null;\r\n            return;\r\n        }\r\n        if (this.packets.getValue() == 1) {\r\n            this.efficientTarget = maxCrystal;\r\n        } else {\r\n            this.crystalMap = MathUtil.sortByValue(this.crystalMap, true);\r\n            for (Map.Entry<Entity, Float> entry : this.crystalMap.entrySet()) {\r\n                Entity crystal = entry.getKey();\r\n                float damage = entry.getValue();\r\n                if (damage >= this.minDamage.getValue() || !this.wasteMinDmgCount.getValue()) {\r\n                    ++this.crystalCount;\r\n                }\r\n                this.attackList.add(crystal);\r\n                ++this.minDmgCount;\r\n            }\r\n        }\r\n    }\r\n\r\n    private boolean shouldSlowBreak(boolean withManual) {\r\n        return withManual && this.manual.getValue() && this.manualMinDmg.getValue() && Mouse.isButtonDown(1) && (!Mouse.isButtonDown(0) || !this.holdFacePlace.getValue()) || this.holdFacePlace.getValue() && this.holdFaceBreak.getValue() && Mouse.isButtonDown(0) && !this.breakTimer.passedMs(this.facePlaceSpeed.getValue()) || this.slowFaceBreak.getValue() && !this.breakTimer.passedMs(this.facePlaceSpeed.getValue());\r\n    }\r\n\r\n    private void placeCrystal() {\r\n        int crystalLimit = this.wasteAmount.getValue();\r\n        if (this.placeTimer.passedMs(this.placeDelay.getValue()) && this.place.getValue() && (this.offHand || this.mainHand || this.switchMode.getValue() == Switch.CALC || this.switchMode.getValue() == Switch.BREAKSLOT && this.switching)) {\r\n            if (!(!this.offHand && !this.mainHand && (this.switchMode.getValue() == Switch.ALWAYS || this.switching) || this.crystalCount < crystalLimit || this.antiSurround.getValue() && this.lastPos != null && this.lastPos.equals(this.placePos))) {\r\n                return;\r\n            }\r\n            this.calculateDamage(this.getTarget(this.targetMode.getValue() == Target.UNSAFE));\r\n            if (target != null && this.placePos != null) {\r\n                if (!this.offHand && !this.mainHand && this.autoSwitch.getValue() != AutoSwitch.NONE && (this.currentDamage > (double) this.minDamage.getValue() || this.lethalSwitch.getValue() && EntityUtil.getHealth(target) <= this.facePlace.getValue()) && !this.switchItem()) {\r\n                    return;\r\n                }\r\n                if (this.currentDamage < (double) this.minDamage.getValue() && this.limitFacePlace.getValue()) {\r\n                    crystalLimit = 1;\r\n                }\r\n                if (this.currentDamage >= (double) this.minMinDmg.getValue() && (this.offHand || this.mainHand || this.autoSwitch.getValue() != AutoSwitch.NONE) && (this.crystalCount < crystalLimit || this.antiSurround.getValue() && this.lastPos != null && this.lastPos.equals(this.placePos)) && (this.currentDamage > (double) this.minDamage.getValue() || this.minDmgCount < crystalLimit) && this.currentDamage >= 1.0 && (DamageUtil.isArmorLow(target, this.minArmor.getValue()) || EntityUtil.getHealth(target) <= this.facePlace.getValue() || this.currentDamage > (double) this.minDamage.getValue() || this.shouldHoldFacePlace())) {\r\n                    float damageOffset = this.damageSync.getValue() == DamageSync.BREAK ? this.dropOff.getValue() - 5.0f : 0.0f;\r\n                    boolean syncflag = false;\r\n                    if (this.syncedFeetPlace.getValue() && this.placePos.equals(this.lastPos) && this.isEligableForFeetSync(target, this.placePos) && !this.syncTimer.passedMs(this.damageSyncTime.getValue()) && target.equals(this.currentSyncTarget) && target.getPosition().equals(this.syncedPlayerPos) && this.damageSync.getValue() != DamageSync.NONE) {\r\n                        this.syncedCrystalPos = this.placePos;\r\n                        this.lastDamage = this.currentDamage;\r\n                        if (this.fullSync.getValue()) {\r\n                            this.lastDamage = 100.0;\r\n                        }\r\n                        syncflag = true;\r\n                    }\r\n                    if (syncflag || this.currentDamage - (double) damageOffset > this.lastDamage || this.syncTimer.passedMs(this.damageSyncTime.getValue()) || this.damageSync.getValue() == DamageSync.NONE) {\r\n                        if (!syncflag && this.damageSync.getValue() != DamageSync.BREAK) {\r\n                            this.lastDamage = this.currentDamage;\r\n                        }\r\n                        this.renderPos = this.placePos;\r\n                        this.renderDamage = this.currentDamage;\r\n                        if (this.switchItem()) {\r\n                            this.currentSyncTarget = target;\r\n                            this.syncedPlayerPos = target.getPosition();\r\n                            if (this.foundDoublePop) {\r\n                                this.totemPops.put(target, new me.derp.quantum.util.Timer().reset());\r\n                            }\r\n                            this.rotateToPos(this.placePos);\r\n                            if (this.addTolowDmg || this.actualSlowBreak.getValue() && this.currentDamage < (double) this.minDamage.getValue()) {\r\n                                lowDmgPos.add(this.placePos);\r\n                            }\r\n                            placedPos.add(this.placePos);\r\n                            if (!this.justRender.getValue()) {\r\n                                if (this.eventMode.getValue() == 2 && this.threadMode.getValue() == ThreadMode.NONE && this.rotateFirst.getValue() && this.rotate.getValue() != Rotate.OFF) {\r\n                                    this.placeInfo = new PlaceInfo(this.placePos, this.offHand, this.placeSwing.getValue(), this.exactHand.getValue());\r\n                                } else {\r\n                                    BlockUtil.placeCrystalOnBlock(this.placePos, this.offHand ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND, this.placeSwing.getValue(), this.exactHand.getValue());\r\n\r\n\r\n                                }\r\n                            }\r\n\r\n\r\n                            this.lastPos = this.placePos;\r\n                            this.placeTimer.reset();\r\n                            this.posConfirmed = false;\r\n                            if (this.syncTimer.passedMs(this.damageSyncTime.getValue())) {\r\n                                this.syncedCrystalPos = null;\r\n                                this.syncTimer.reset();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                this.renderPos = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    private boolean shouldHoldFacePlace() {\r\n        this.addTolowDmg = false;\r\n        if (this.holdFacePlace.getValue() && Mouse.isButtonDown(0)) {\r\n            this.addTolowDmg = true;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private boolean switchItem() {\r\n        if (this.offHand || this.mainHand) {\r\n            return true;\r\n        }\r\n        switch (this.autoSwitch.getValue()) {\r\n            case NONE: {\r\n                return false;\r\n            }\r\n            case TOGGLE: {\r\n                if (!this.switching) {\r\n                    return false;\r\n                }\r\n            }\r\n            case ALWAYS: {\r\n                if (!this.doSwitch()) break;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private boolean doSwitch() {\r\n        if (this.offhandSwitch.getValue()) {\r\n            Offhand module = Quantum.moduleManager.getModuleByClass(Offhand.class);\r\n            if (module.isOff()) {\r\n                Command.sendMessage(\"<\" + this.getDisplayName() + \"> \" + \"\\u00a7c\" + \"Switch failed. Enable the Offhand module.\");\r\n                this.switching = false;\r\n                return false;\r\n            }\r\n            this.switching = false;\r\n            return true;\r\n        }\r\n        if (AutoCrystal.mc.player.getHeldItemOffhand().getItem() == Items.END_CRYSTAL) {\r\n            this.mainHand = false;\r\n        } else {\r\n            InventoryUtil.switchToHotbarSlot(ItemEndCrystal.class, false);\r\n            this.mainHand = true;\r\n        }\r\n        this.switching = false;\r\n        return true;\r\n    }\r\n\r\n    private void calculateDamage(EntityPlayer targettedPlayer) {\r\n        BlockPos playerPos;\r\n        Block web;\r\n        if (targettedPlayer == null && this.targetMode.getValue() != Target.DAMAGE && !this.fullCalc.getValue()) {\r\n            return;\r\n        }\r\n        float maxDamage = 0.5f;\r\n        EntityPlayer currentTarget = null;\r\n        BlockPos currentPos = null;\r\n        float maxSelfDamage = 0.0f;\r\n        this.foundDoublePop = false;\r\n        BlockPos setToAir = null;\r\n        IBlockState state = null;\r\n        if (this.webAttack.getValue() && targettedPlayer != null && (web = AutoCrystal.mc.world.getBlockState(playerPos = new BlockPos(targettedPlayer.getPositionVector())).getBlock()) == Blocks.WEB) {\r\n            setToAir = playerPos;\r\n            state = AutoCrystal.mc.world.getBlockState(playerPos);\r\n            AutoCrystal.mc.world.setBlockToAir(playerPos);\r\n        }\r\n        block0:\r\n        for (BlockPos pos : BlockUtil.possiblePlacePositions(this.placeRange.getValue(), this.antiSurround.getValue(), this.oneDot15.getValue())) {\r\n            if (!BlockUtil.rayTracePlaceCheck(pos, (this.raytrace.getValue() == Raytrace.PLACE || this.raytrace.getValue() == Raytrace.FULL) && AutoCrystal.mc.player.getDistanceSq(pos) > MathUtil.square(this.placetrace.getValue()), 1.0f))\r\n                continue;\r\n            float selfDamage = -1.0f;\r\n            if (DamageUtil.canTakeDamage(this.suicide.getValue())) {\r\n                selfDamage = DamageUtil.calculateDamage(pos, AutoCrystal.mc.player);\r\n            }\r\n            if (!((double) selfDamage + 0.5 < (double) EntityUtil.getHealth(AutoCrystal.mc.player)) || !(selfDamage <= this.maxSelfPlace.getValue()))\r\n                continue;\r\n            if (targettedPlayer != null) {\r\n                float playerDamage = DamageUtil.calculateDamage(pos, targettedPlayer);\r\n                if (this.calcEvenIfNoDamage.getValue() && (this.antiFriendPop.getValue() == AntiFriendPop.ALL || this.antiFriendPop.getValue() == AntiFriendPop.PLACE)) {\r\n                    boolean friendPop = false;\r\n                    for (EntityPlayer friend : AutoCrystal.mc.world.playerEntities) {\r\n                        float friendDamage;\r\n                        if (friend == null || AutoCrystal.mc.player.equals(friend) || friend.getDistanceSq(pos) > MathUtil.square(this.range.getValue() + this.placeRange.getValue()) || !Quantum.friendManager.isFriend(friend) || !((double) (friendDamage = DamageUtil.calculateDamage(pos, friend)) > (double) EntityUtil.getHealth(friend) + 0.5))\r\n                            continue;\r\n                        friendPop = true;\r\n                        break;\r\n                    }\r\n                    if (friendPop) continue;\r\n                }\r\n                if (this.isDoublePoppable(targettedPlayer, playerDamage) && (currentPos == null || targettedPlayer.getDistanceSq(pos) < targettedPlayer.getDistanceSq(currentPos))) {\r\n                    currentTarget = targettedPlayer;\r\n                    maxDamage = playerDamage;\r\n                    currentPos = pos;\r\n                    this.foundDoublePop = true;\r\n                    continue;\r\n                }\r\n                if (this.foundDoublePop || !(playerDamage > maxDamage) && (!this.extraSelfCalc.getValue() || !(playerDamage >= maxDamage) || !(selfDamage < maxSelfDamage)) || !(playerDamage > selfDamage || playerDamage > this.minDamage.getValue() && !DamageUtil.canTakeDamage(this.suicide.getValue())) && !(playerDamage > EntityUtil.getHealth(targettedPlayer)))\r\n                    continue;\r\n                maxDamage = playerDamage;\r\n                currentTarget = targettedPlayer;\r\n                currentPos = pos;\r\n                maxSelfDamage = selfDamage;\r\n                continue;\r\n            }\r\n            float maxDamageBefore = maxDamage;\r\n            EntityPlayer currentTargetBefore = currentTarget;\r\n            BlockPos currentPosBefore = currentPos;\r\n            float maxSelfDamageBefore = maxSelfDamage;\r\n            for (EntityPlayer player : AutoCrystal.mc.world.playerEntities) {\r\n                float friendDamage;\r\n                if (EntityUtil.isValid(player, this.placeRange.getValue() + this.range.getValue())) {\r\n                    if (this.antiNaked.getValue() && DamageUtil.isNaked(player)) continue;\r\n                    float playerDamage = DamageUtil.calculateDamage(pos, player);\r\n                    if (this.doublePopOnDamage.getValue() && this.isDoublePoppable(player, playerDamage) && (currentPos == null || player.getDistanceSq(pos) < player.getDistanceSq(currentPos))) {\r\n                        currentTarget = player;\r\n                        maxDamage = playerDamage;\r\n                        currentPos = pos;\r\n                        maxSelfDamage = selfDamage;\r\n                        this.foundDoublePop = true;\r\n                        if (this.antiFriendPop.getValue() != AntiFriendPop.BREAK && this.antiFriendPop.getValue() != AntiFriendPop.PLACE)\r\n                            continue;\r\n                        continue block0;\r\n                    }\r\n                    if (this.foundDoublePop || !(playerDamage > maxDamage) && (!this.extraSelfCalc.getValue() || !(playerDamage >= maxDamage) || !(selfDamage < maxSelfDamage)) || !(playerDamage > selfDamage || playerDamage > this.minDamage.getValue() && DamageUtil.canTakeDamage(this.suicide.getValue())) && !(playerDamage > EntityUtil.getHealth(player)))\r\n                        continue;\r\n                    maxDamage = playerDamage;\r\n                    currentTarget = player;\r\n                    currentPos = pos;\r\n                    maxSelfDamage = selfDamage;\r\n                    continue;\r\n                }\r\n                if (this.antiFriendPop.getValue() != AntiFriendPop.ALL && this.antiFriendPop.getValue() != AntiFriendPop.PLACE || player == null || !(player.getDistanceSq(pos) <= MathUtil.square(this.range.getValue() + this.placeRange.getValue())) || !Quantum.friendManager.isFriend(player) || !((double) (friendDamage = DamageUtil.calculateDamage(pos, player)) > (double) EntityUtil.getHealth(player) + 0.5))\r\n                    continue;\r\n                maxDamage = maxDamageBefore;\r\n                currentTarget = currentTargetBefore;\r\n                currentPos = currentPosBefore;\r\n                maxSelfDamage = maxSelfDamageBefore;\r\n                continue block0;\r\n            }\r\n        }\r\n        if (setToAir != null) {\r\n            AutoCrystal.mc.world.setBlockState(setToAir, state);\r\n            this.webPos = currentPos;\r\n        }\r\n        target = currentTarget;\r\n        this.currentDamage = maxDamage;\r\n        this.placePos = currentPos;\r\n    }\r\n\r\n    private EntityPlayer getTarget(boolean unsafe) {\r\n        if (this.targetMode.getValue() == Target.DAMAGE) {\r\n            return null;\r\n        }\r\n        EntityPlayer currentTarget = null;\r\n        for (EntityPlayer player : AutoCrystal.mc.world.playerEntities) {\r\n            if (EntityUtil.isntValid(player, this.placeRange.getValue() + this.range.getValue()) || this.antiNaked.getValue() && DamageUtil.isNaked(player) || unsafe && EntityUtil.isSafe(player))\r\n                continue;\r\n            if (this.minArmor.getValue() > 0 && DamageUtil.isArmorLow(player, this.minArmor.getValue())) {\r\n                currentTarget = player;\r\n                break;\r\n            }\r\n            if (currentTarget == null) {\r\n                currentTarget = player;\r\n                continue;\r\n            }\r\n            if (!(AutoCrystal.mc.player.getDistanceSq(player) < AutoCrystal.mc.player.getDistanceSq(currentTarget)))\r\n                continue;\r\n            currentTarget = player;\r\n        }\r\n        if (unsafe && currentTarget == null) {\r\n            return this.getTarget(false);\r\n        }\r\n        if (this.predictPos.getValue() && currentTarget != null) {\r\n            currentTarget.getUniqueID();\r\n            GameProfile profile = new GameProfile(currentTarget.getUniqueID(), currentTarget.getName());\r\n            EntityOtherPlayerMP newTarget = new EntityOtherPlayerMP(AutoCrystal.mc.world, profile);\r\n            Vec3d extrapolatePosition = MathUtil.extrapolatePlayerPosition(currentTarget, this.predictTicks.getValue());\r\n            newTarget.copyLocationAndAnglesFrom(currentTarget);\r\n            newTarget.posX = extrapolatePosition.x;\r\n            newTarget.posY = extrapolatePosition.y;\r\n            newTarget.posZ = extrapolatePosition.z;\r\n            newTarget.setHealth(EntityUtil.getHealth(currentTarget));\r\n            newTarget.inventory.copyInventory(currentTarget.inventory);\r\n            currentTarget = newTarget;\r\n        }\r\n        return currentTarget;\r\n    }\r\n\r\n    private void breakCrystal() {\r\n        if (this.explode.getValue() && this.breakTimer.passedMs(this.breakDelay.getValue()) && (this.switchMode.getValue() == Switch.ALWAYS || this.mainHand || this.offHand)) {\r\n            if (this.packets.getValue() == 1 && this.efficientTarget != null) {\r\n                if (this.justRender.getValue()) {\r\n                    return;\r\n                }\r\n                if (this.syncedFeetPlace.getValue() && this.gigaSync.getValue() && this.syncedCrystalPos != null && this.damageSync.getValue() != DamageSync.NONE) {\r\n                    return;\r\n                }\r\n                this.rotateTo(this.efficientTarget);\r\n                this.attackEntity(this.efficientTarget);\r\n                this.breakTimer.reset();\r\n            } else if (!this.attackList.isEmpty()) {\r\n                if (this.justRender.getValue()) {\r\n                    return;\r\n                }\r\n                if (this.syncedFeetPlace.getValue() && this.gigaSync.getValue() && this.syncedCrystalPos != null && this.damageSync.getValue() != DamageSync.NONE) {\r\n                    return;\r\n                }\r\n                for (int i = 0; i < this.packets.getValue(); ++i) {\r\n                    Entity entity = this.attackList.poll();\r\n                    if (entity == null) continue;\r\n                    this.rotateTo(entity);\r\n                    this.attackEntity(entity);\r\n                }\r\n                this.breakTimer.reset();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void attackEntity(Entity entity) {\r\n        if (entity != null) {\r\n            if (this.eventMode.getValue() == 2 && this.threadMode.getValue() == ThreadMode.NONE && this.rotateFirst.getValue() && this.rotate.getValue() != Rotate.OFF) {\r\n                this.packetUseEntities.add(new CPacketUseEntity(entity));\r\n            } else {\r\n                EntityUtil.attackEntity(entity, this.sync.getValue(), this.breakSwing.getValue());\r\n                brokenPos.add(new BlockPos(entity.getPositionVector()).down());\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private void manualBreaker() {\r\n        RayTraceResult result;\r\n        if (this.rotate.getValue() != Rotate.OFF && this.eventMode.getValue() != 2 && this.rotating) {\r\n            if (this.didRotation) {\r\n                AutoCrystal.mc.player.rotationPitch = (float) ((double) AutoCrystal.mc.player.rotationPitch + 4.0E-4);\r\n                this.didRotation = false;\r\n            } else {\r\n                AutoCrystal.mc.player.rotationPitch = (float) ((double) AutoCrystal.mc.player.rotationPitch - 4.0E-4);\r\n                this.didRotation = true;\r\n            }\r\n        }\r\n        if ((this.offHand || this.mainHand) && this.manual.getValue() && this.manualTimer.passedMs(this.manualBreak.getValue()) && Mouse.isButtonDown(1) && AutoCrystal.mc.player.getHeldItemOffhand().getItem() != Items.GOLDEN_APPLE && AutoCrystal.mc.player.inventory.getCurrentItem().getItem() != Items.GOLDEN_APPLE && AutoCrystal.mc.player.inventory.getCurrentItem().getItem() != Items.BOW && AutoCrystal.mc.player.inventory.getCurrentItem().getItem() != Items.EXPERIENCE_BOTTLE && (result = AutoCrystal.mc.objectMouseOver) != null) {\r\n            switch (result.typeOfHit) {\r\n                case ENTITY: {\r\n                    Entity entity = result.entityHit;\r\n                    if (!(entity instanceof EntityEnderCrystal)) break;\r\n                    EntityUtil.attackEntity(entity, this.sync.getValue(), this.breakSwing.getValue());\r\n                    this.manualTimer.reset();\r\n                    break;\r\n                }\r\n                case BLOCK: {\r\n                    BlockPos mousePos = AutoCrystal.mc.objectMouseOver.getBlockPos().up();\r\n                    for (Entity target : AutoCrystal.mc.world.getEntitiesWithinAABBExcludingEntity(null, new AxisAlignedBB(mousePos))) {\r\n                        if (!(target instanceof EntityEnderCrystal)) continue;\r\n                        EntityUtil.attackEntity(target, this.sync.getValue(), this.breakSwing.getValue());\r\n                        this.manualTimer.reset();\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void rotateTo(Entity entity) {\r\n        switch (this.rotate.getValue()) {\r\n            case OFF: {\r\n                this.rotating = false;\r\n            }\r\n            case PLACE: {\r\n                break;\r\n            }\r\n            case BREAK:\r\n            case ALL: {\r\n                float[] angle = MathUtil.calcAngle(AutoCrystal.mc.player.getPositionEyes(mc.getRenderPartialTicks()), entity.getPositionVector());\r\n                if (this.eventMode.getValue() == 2 && this.threadMode.getValue() == ThreadMode.NONE) {\r\n                    Quantum.rotationManager.setPlayerRotations(angle[0], angle[1]);\r\n                    break;\r\n                }\r\n                this.yaw = angle[0];\r\n                this.pitch = angle[1];\r\n                this.rotating = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void rotateToPos(BlockPos pos) {\r\n        switch (this.rotate.getValue()) {\r\n            case OFF: {\r\n                this.rotating = false;\r\n            }\r\n            case BREAK: {\r\n                break;\r\n            }\r\n            case PLACE:\r\n            case ALL: {\r\n                float[] angle = MathUtil.calcAngle(AutoCrystal.mc.player.getPositionEyes(mc.getRenderPartialTicks()), new Vec3d((float) pos.getX() + 0.5f, (float) pos.getY() - 0.5f, (float) pos.getZ() + 0.5f));\r\n                if (this.eventMode.getValue() == 2 && this.threadMode.getValue() == ThreadMode.NONE) {\r\n                    Quantum.rotationManager.setPlayerRotations(angle[0], angle[1]);\r\n                    break;\r\n                }\r\n                this.yaw = angle[0];\r\n                this.pitch = angle[1];\r\n                this.rotating = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private boolean isDoublePoppable(EntityPlayer player, float damage) {\r\n        float health;\r\n        if (this.doublePop.getValue() && (double) (health = EntityUtil.getHealth(player)) <= this.popHealth.getValue() && (double) damage > (double) health + 0.5 && damage <= this.popDamage.getValue()) {\r\n            Timer timer = this.totemPops.get(player);\r\n            return timer == null || timer.passedMs(this.popTime.getValue());\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private boolean isValid(Entity entity) {\r\n        return entity != null && AutoCrystal.mc.player.getDistanceSq(entity) <= MathUtil.square(this.breakRange.getValue()) && (this.raytrace.getValue() == Raytrace.NONE || this.raytrace.getValue() == Raytrace.PLACE || AutoCrystal.mc.player.canEntityBeSeen(entity) || !AutoCrystal.mc.player.canEntityBeSeen(entity) && AutoCrystal.mc.player.getDistanceSq(entity) <= MathUtil.square(this.breaktrace.getValue()));\r\n    }\r\n\r\n    private boolean isEligableForFeetSync(EntityPlayer player, BlockPos pos) {\r\n        if (this.holySync.getValue()) {\r\n            BlockPos playerPos = new BlockPos(player.getPositionVector());\r\n            for (EnumFacing facing : EnumFacing.values()) {\r\n                BlockPos holyPos;\r\n                if (facing == EnumFacing.DOWN || facing == EnumFacing.UP || !pos.equals(holyPos = playerPos.down().offset(facing)))\r\n                    continue;\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public enum PredictTimer {\r\n        NONE,\r\n        BREAK,\r\n        PREDICT\r\n\r\n    }\r\n\r\n    public enum AntiFriendPop {\r\n        NONE,\r\n        PLACE,\r\n        BREAK,\r\n        ALL\r\n\r\n    }\r\n\r\n    public enum ThreadMode {\r\n        NONE,\r\n        POOL,\r\n        SOUND,\r\n        WHILE\r\n\r\n    }\r\n\r\n    public enum AutoSwitch {\r\n        NONE,\r\n        TOGGLE,\r\n        ALWAYS\r\n\r\n    }\r\n\r\n    public enum Raytrace {\r\n        NONE,\r\n        PLACE,\r\n        BREAK,\r\n        FULL\r\n\r\n    }\r\n\r\n    public enum Switch {\r\n        ALWAYS,\r\n        BREAKSLOT,\r\n        CALC\r\n\r\n    }\r\n\r\n    public enum Logic {\r\n        BREAKPLACE,\r\n        PLACEBREAK\r\n\r\n    }\r\n\r\n    public enum Target {\r\n        CLOSEST,\r\n        UNSAFE,\r\n        DAMAGE\r\n\r\n    }\r\n\r\n    public enum Rotate {\r\n        OFF,\r\n        PLACE,\r\n        BREAK,\r\n        ALL\r\n\r\n    }\r\n\r\n    public enum DamageSync {\r\n        NONE,\r\n        PLACE,\r\n        BREAK\r\n\r\n    }\r\n\r\n    public enum Settings {\r\n        PLACE,\r\n        BREAK,\r\n        RENDER,\r\n        MISC,\r\n        DEV\r\n\r\n    }\r\n\r\n    public static class PlaceInfo {\r\n        private final BlockPos pos;\r\n        private final boolean offhand;\r\n        private final boolean placeSwing;\r\n        private final boolean exactHand;\r\n\r\n        public PlaceInfo(BlockPos pos, boolean offhand, boolean placeSwing, boolean exactHand) {\r\n            this.pos = pos;\r\n            this.offhand = offhand;\r\n            this.placeSwing = placeSwing;\r\n            this.exactHand = exactHand;\r\n        }\r\n\r\n        public void runPlace() {\r\n\r\n\r\n            BlockUtil.placeCrystalOnBlock(this.pos, this.offhand ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND, this.placeSwing, this.exactHand);\r\n\r\n\r\n        }\r\n    }\r\n\r\n    private static class RAutoCrystal\r\n            implements Runnable {\r\n        private static RAutoCrystal instance;\r\n        private AutoCrystal autoCrystal;\r\n\r\n        private RAutoCrystal() {\r\n        }\r\n\r\n        public static RAutoCrystal getInstance(AutoCrystal autoCrystal) {\r\n            if (instance == null) {\r\n                instance = new RAutoCrystal();\r\n                RAutoCrystal.instance.autoCrystal = autoCrystal;\r\n            }\r\n            return instance;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            if (this.autoCrystal.threadMode.getValue() == ThreadMode.WHILE) {\r\n                while (this.autoCrystal.isOn() && this.autoCrystal.threadMode.getValue() == ThreadMode.WHILE) {\r\n                    while (Quantum.eventManager.ticksOngoing()) {\r\n                    }\r\n                    if (this.autoCrystal.shouldInterrupt.get()) {\r\n                        this.autoCrystal.shouldInterrupt.set(false);\r\n                        this.autoCrystal.syncroTimer.reset();\r\n                        this.autoCrystal.thread.interrupt();\r\n                        break;\r\n                    }\r\n                    this.autoCrystal.threadOngoing.set(true);\r\n                    this.autoCrystal.doAutoCrystal();\r\n                    this.autoCrystal.threadOngoing.set(false);\r\n                    try {\r\n                        Thread.sleep(this.autoCrystal.threadDelay.getValue());\r\n                    } catch (InterruptedException e) {\r\n                        this.autoCrystal.thread.interrupt();\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            } else if (this.autoCrystal.threadMode.getValue() != ThreadMode.NONE && this.autoCrystal.isOn()) {\r\n                while (Quantum.eventManager.ticksOngoing()) {\r\n                }\r\n                this.autoCrystal.threadOngoing.set(true);\r\n                this.autoCrystal.doAutoCrystal();\r\n                this.autoCrystal.threadOngoing.set(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    public static\r\n    class switchTimer {\r\n        private long time = -1L;\r\n\r\n        public boolean passedS(double s) {\r\n            return this.passedMs((long) s * 1000L);\r\n        }\r\n\r\n        public boolean passedDms(double dms) {\r\n            return this.passedMs((long) dms * 10L);\r\n        }\r\n\r\n        public boolean passedDs(double ds) {\r\n            return this.passedMs((long) ds * 100L);\r\n        }\r\n\r\n        public boolean passedMs(long ms) {\r\n            return this.passedNS(this.convertToNS(ms));\r\n        }\r\n\r\n        public void setMs(long ms) {\r\n            this.time = System.nanoTime() - this.convertToNS(ms);\r\n        }\r\n\r\n        public boolean passedNS(long ns) {\r\n            return System.nanoTime() - this.time >= ns;\r\n        }\r\n\r\n        public long getPassedTimeMs() {\r\n            return this.getMs(System.nanoTime() - this.time);\r\n        }\r\n\r\n        public AutoCrystal.switchTimer reset() {\r\n            this.time = System.nanoTime();\r\n            return this;\r\n        }\r\n\r\n        public long getMs(long time) {\r\n            return time / 1000000L;\r\n        }\r\n\r\n        public long convertToNS(long time) {\r\n            return time * 1000000L;\r\n        }\r\n    }\r\n\r\n    public Color getCurrentColor() {\r\n        return new Color(this.red.getValue(), this.green.getValue(), this.blue.getValue(), this.alpha.getValue());\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/me/derp/quantum/features/modules/combat/AutoCrystal.java b/src/main/java/me/derp/quantum/features/modules/combat/AutoCrystal.java
--- a/src/main/java/me/derp/quantum/features/modules/combat/AutoCrystal.java	(revision 7b4fc7b1b7f98d347c60677eb835323ad7521d92)
+++ b/src/main/java/me/derp/quantum/features/modules/combat/AutoCrystal.java	(date 1636353956812)
@@ -631,7 +631,7 @@
         this.offHand = AutoCrystal.mc.player.getHeldItemOffhand().getItem() == Items.END_CRYSTAL;
         this.currentDamage = 0.0;
         this.placePos = null;
-        if (this.lastSlot != AutoCrystal.mc.player.inventory.currentItem || AutoTrap.isPlacing || Surround.isPlacing) {
+        if (this.lastSlot != AutoCrystal.mc.player.inventory.currentItem || AutoTrap.isPlacing) {
             this.lastSlot = AutoCrystal.mc.player.inventory.currentItem;
             this.switchTimer.reset();
         }
Index: src/main/java/me/derp/quantum/mixin/mixins/MixinItemRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package me.derp.quantum.mixin.mixins;\r\n\r\nimport me.derp.quantum.features.modules.render.NoRender;\r\nimport me.derp.quantum.features.modules.render.ViewModel;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.entity.AbstractClientPlayer;\r\nimport net.minecraft.client.renderer.GlStateManager;\r\nimport net.minecraft.client.renderer.ItemRenderer;\r\nimport net.minecraft.client.renderer.block.model.ItemCameraTransforms;\r\nimport net.minecraft.entity.EntityLivingBase;\r\nimport net.minecraft.item.ItemStack;\r\nimport net.minecraft.util.EnumHand;\r\nimport net.minecraft.util.EnumHandSide;\r\nimport org.spongepowered.asm.mixin.Final;\r\nimport org.spongepowered.asm.mixin.Mixin;\r\nimport org.spongepowered.asm.mixin.Shadow;\r\nimport org.spongepowered.asm.mixin.injection.At;\r\nimport org.spongepowered.asm.mixin.injection.Inject;\r\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\r\n\r\n@Mixin(value = {ItemRenderer.class})\r\npublic abstract class MixinItemRenderer {\r\n    @Shadow\r\n    @Final\r\n    public Minecraft mc;\r\n    private final boolean injection = true;\r\n\r\n    @Shadow\r\n    public abstract void renderItemInFirstPerson(AbstractClientPlayer var1, float var2, float var3, EnumHand var4, float var5, ItemStack var6, float var7);\r\n\r\n    @Shadow\r\n    protected abstract void renderArmFirstPerson(float var1, float var2, EnumHandSide var3);\r\n\r\n    @Inject(method = {\"renderItemInFirstPerson(Lnet/minecraft/client/entity/AbstractClientPlayer;FFLnet/minecraft/util/EnumHand;FLnet/minecraft/item/ItemStack;F)V\"}, at = {@At(value = \"HEAD\")}, cancellable = true)\r\n    public void renderItemInFirstPersonHook(AbstractClientPlayer player, float p_1874572, float p_1874573, EnumHand hand, float p_1874575, ItemStack stack, float p_1874577, CallbackInfo info) {\r\n    }\r\n\r\n    @Inject(method = {\"renderFireInFirstPerson\"}, at = {@At(value = \"HEAD\")}, cancellable = true)\r\n    public void renderFireInFirstPersonHook(CallbackInfo info) {\r\n        if (NoRender.getInstance().isOn() && NoRender.getInstance().fire.getValue()) {\r\n            info.cancel();\r\n        }\r\n    }\r\n\r\n    @Inject(method = {\"renderSuffocationOverlay\"}, at = {@At(value = \"HEAD\")}, cancellable = true)\r\n    public void renderSuffocationOverlay(CallbackInfo ci) {\r\n        if (NoRender.getInstance().isOn() && NoRender.getInstance().blocks.getValue()) {\r\n            ci.cancel();\r\n        }\r\n    }\r\n\r\n    @Inject(method = \"renderItemSide\", at = @At(\"HEAD\"))\r\n    public void renderItemSide(EntityLivingBase entitylivingbaseIn, ItemStack heldStack, ItemCameraTransforms.TransformType transform, boolean leftHanded, CallbackInfo ci) {\r\n        if (ViewModel.INSTANCE.isEnabled()) {\r\n            GlStateManager.scale(ViewModel.INSTANCE.scaleX.getValue() / 100F, ViewModel.INSTANCE.scaleY.getValue() / 100F, ViewModel.INSTANCE.scaleZ.getValue() / 100F);\r\n            if (transform == ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND) {\r\n                GlStateManager.translate(ViewModel.INSTANCE.translateX.getValue() / 200F, ViewModel.INSTANCE.translateY.getValue() / 200F, ViewModel.INSTANCE.translateZ.getValue() / 200F);\r\n                GlStateManager.rotate(ViewModel.INSTANCE.rotateX.getValue(), 1, 0, 0);\r\n                GlStateManager.rotate(ViewModel.INSTANCE.rotateY.getValue(), 0, 1, 0);\r\n                GlStateManager.rotate(ViewModel.INSTANCE.rotateZ.getValue(), 0, 0, 1);\r\n            } else if (transform == ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND) {\r\n                GlStateManager.translate(-ViewModel.INSTANCE.translateX.getValue() / 200F, ViewModel.INSTANCE.translateY.getValue() / 200F, ViewModel.INSTANCE.translateZ.getValue() / 200F);\r\n                GlStateManager.rotate(-ViewModel.INSTANCE.rotateX.getValue(), 1, 0, 0);\r\n                GlStateManager.rotate(ViewModel.INSTANCE.rotateY.getValue(), 0, 1, 0);\r\n                GlStateManager.rotate(ViewModel.INSTANCE.rotateZ.getValue(), 0, 0, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/me/derp/quantum/mixin/mixins/MixinItemRenderer.java b/src/main/java/me/derp/quantum/mixin/mixins/MixinItemRenderer.java
--- a/src/main/java/me/derp/quantum/mixin/mixins/MixinItemRenderer.java	(revision 7b4fc7b1b7f98d347c60677eb835323ad7521d92)
+++ b/src/main/java/me/derp/quantum/mixin/mixins/MixinItemRenderer.java	(date 1636266799881)
@@ -1,7 +1,10 @@
 package me.derp.quantum.mixin.mixins;
 
+import me.derp.quantum.features.modules.client.ClickGui;
 import me.derp.quantum.features.modules.render.NoRender;
 import me.derp.quantum.features.modules.render.ViewModel;
+import me.derp.quantum.features.modules.render.Wireframe;
+import me.derp.quantum.util.ColorUtil;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.AbstractClientPlayer;
 import net.minecraft.client.renderer.GlStateManager;
@@ -11,6 +14,7 @@
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.EnumHand;
 import net.minecraft.util.EnumHandSide;
+import org.lwjgl.opengl.GL11;
 import org.spongepowered.asm.mixin.Final;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;
@@ -52,6 +56,9 @@
     @Inject(method = "renderItemSide", at = @At("HEAD"))
     public void renderItemSide(EntityLivingBase entitylivingbaseIn, ItemStack heldStack, ItemCameraTransforms.TransformType transform, boolean leftHanded, CallbackInfo ci) {
         if (ViewModel.INSTANCE.isEnabled()) {
+            GL11.glColor4f((ClickGui.getInstance()).rainbow.getValue() ? (ColorUtil.rainbow((ClickGui.getInstance()).rainbowHue.getValue()).getRed() / 255.0F) : 130 / 255, (ClickGui.getInstance()).rainbow.getValue() ? (ColorUtil.rainbow((ClickGui.getInstance()).rainbowHue.getValue()).getGreen() / 255.0F) : 0/ 255, (ClickGui.getInstance()).rainbow.getValue() ? (ColorUtil.rainbow((ClickGui.getInstance()).rainbowHue.getValue()).getBlue() / 255.0F) : 255/255, (Wireframe.getINSTANCE()).alpha.getValue() / 255.0F);
+            GL11.glEnable(2929);
+            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_COLOR, GlStateManager.DestFactor.ONE);
             GlStateManager.scale(ViewModel.INSTANCE.scaleX.getValue() / 100F, ViewModel.INSTANCE.scaleY.getValue() / 100F, ViewModel.INSTANCE.scaleZ.getValue() / 100F);
             if (transform == ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND) {
                 GlStateManager.translate(ViewModel.INSTANCE.translateX.getValue() / 200F, ViewModel.INSTANCE.translateY.getValue() / 200F, ViewModel.INSTANCE.translateZ.getValue() / 200F);
@@ -64,6 +71,7 @@
                 GlStateManager.rotate(ViewModel.INSTANCE.rotateY.getValue(), 0, 1, 0);
                 GlStateManager.rotate(ViewModel.INSTANCE.rotateZ.getValue(), 0, 0, 1);
             }
+            GL11.glDisable(2929);
         }
     }
 
Index: src/main/java/me/derp/quantum/features/modules/misc/PopCounter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package me.derp.quantum.features.modules.misc;\r\n\r\nimport com.mojang.realmsclient.gui.ChatFormatting;\r\nimport me.derp.quantum.features.command.Command;\r\nimport me.derp.quantum.features.modules.Module;\r\nimport me.derp.quantum.features.modules.client.HUD;\r\nimport me.derp.quantum.features.modules.client.ModuleTools;\r\nimport net.minecraft.entity.player.EntityPlayer;\r\n\r\nimport java.util.HashMap;\r\n\r\npublic class PopCounter\r\n        extends Module {\r\n    public static HashMap<String, Integer> TotemPopContainer = new HashMap<>();\r\n    private static PopCounter INSTANCE = new PopCounter();\r\n\r\n\r\n    public PopCounter() {\r\n        super(\"PopCounter\", \"Counts other players totem pops.\", Module.Category.MISC, true, false, false);\r\n        this.setInstance();\r\n    }\r\n\r\n    public static PopCounter getInstance() {\r\n        if (INSTANCE == null) {\r\n            INSTANCE = new PopCounter();\r\n        }\r\n        return INSTANCE;\r\n    }\r\n\r\n    private void setInstance() {\r\n        INSTANCE = this;\r\n    }\r\n\r\n    @Override\r\n    public void onEnable() {\r\n        TotemPopContainer.clear();\r\n    }\r\n\r\n    public String death1(EntityPlayer player) {\r\n        int l_Count = TotemPopContainer.get(player.getName());\r\n        TotemPopContainer.remove(player.getName());\r\n        if (l_Count == 1) {\r\n            if (ModuleTools.getInstance().isEnabled()) {\r\n                switch (ModuleTools.getInstance().popNotifier.getValue()) {\r\n                    case FUTURE: {\r\n                        return ChatFormatting.RED + \"[Future] \" + ChatFormatting.GREEN + player.getName() + ChatFormatting.GRAY + \" died after popping \" + ChatFormatting.GREEN + l_Count + ChatFormatting.GRAY + \" totem.\";\r\n                    }\r\n                    case PHOBOS: {\r\n                        return ChatFormatting.GOLD + player.getName() + ChatFormatting.RED + \" died after popping \" + ChatFormatting.GOLD + l_Count + ChatFormatting.RED + \" totem.\";\r\n                    }\r\n                    case DOTGOD: {\r\n                        return ChatFormatting.DARK_PURPLE + \"[\" + ChatFormatting.LIGHT_PURPLE + \"DotGod.CC\" + ChatFormatting.DARK_PURPLE + \"] \" + ChatFormatting.LIGHT_PURPLE + player.getName() + \" died after popping \" + ChatFormatting.GREEN + l_Count + ChatFormatting.LIGHT_PURPLE + \" time!\";\r\n                    }\r\n                    case NONE: {\r\n                        return HUD.getInstance().getCommandMessage() + ChatFormatting.WHITE + player.getName() + \" died after popping \" + ChatFormatting.GREEN + l_Count + ChatFormatting.WHITE + \" Totem!\";\r\n\r\n                    }\r\n                }\r\n            } else {\r\n                return HUD.getInstance().getCommandMessage() + ChatFormatting.WHITE + player.getName() + \" died after popping \" + ChatFormatting.GREEN + l_Count + ChatFormatting.WHITE + \" Totem!\";\r\n\r\n            }\r\n        } else {\r\n            if (ModuleTools.getInstance().isEnabled()) {\r\n                switch (ModuleTools.getInstance().popNotifier.getValue()) {\r\n                    case FUTURE: {\r\n                        return ChatFormatting.RED + \"[Future] \" + ChatFormatting.GREEN + player.getName() + ChatFormatting.GRAY + \" died after popping \" + ChatFormatting.GREEN + l_Count + ChatFormatting.GRAY + \" totems.\";\r\n                    }\r\n                    case PHOBOS: {\r\n                        return ChatFormatting.GOLD + player.getName() + ChatFormatting.RED + \" died after popping \" + ChatFormatting.GOLD + l_Count + ChatFormatting.RED + \" totems.\";\r\n                    }\r\n                    case DOTGOD: {\r\n                        return ChatFormatting.DARK_PURPLE + \"[\" + ChatFormatting.LIGHT_PURPLE + \"DotGod.CC\" + ChatFormatting.DARK_PURPLE + \"] \" + ChatFormatting.LIGHT_PURPLE + player.getName() + \" died after popping \" + ChatFormatting.GREEN + l_Count + ChatFormatting.LIGHT_PURPLE + \" times!\";\r\n                    }\r\n                    case NONE: {\r\n                        return HUD.getInstance().getCommandMessage() + ChatFormatting.WHITE + player.getName() + \" died after popping \" + ChatFormatting.GREEN + l_Count + ChatFormatting.WHITE + \" Totems!\";\r\n\r\n                    }\r\n                }\r\n            } else {\r\n                return HUD.getInstance().getCommandMessage() + ChatFormatting.WHITE + player.getName() + \" died after popping \" + ChatFormatting.GREEN + l_Count + ChatFormatting.WHITE + \" Totems!\";\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public void onDeath(EntityPlayer player) {\r\n        if (PopCounter.fullNullCheck()) {\r\n            return;\r\n        }\r\n        if (getInstance().isDisabled())\r\n            return;\r\n        if (PopCounter.mc.player.equals(player)) {\r\n            return;\r\n        }\r\n        if (TotemPopContainer.containsKey(player.getName())) {\r\n            Command.sendSilentMessage(death1(player));\r\n        }\r\n    }\r\n\r\n    public String pop(EntityPlayer player) {\r\n        int l_Count = 1;\r\n        if (TotemPopContainer.containsKey(player.getName())) {\r\n            l_Count = TotemPopContainer.get(player.getName());\r\n            TotemPopContainer.put(player.getName(), ++l_Count);\r\n        } else {\r\n            TotemPopContainer.put(player.getName(), l_Count);\r\n        }\r\n        if (l_Count == 1) {\r\n            if (ModuleTools.getInstance().isEnabled()) {\r\n                switch (ModuleTools.getInstance().popNotifier.getValue()) {\r\n                    case FUTURE: {\r\n                        return ChatFormatting.RED + \"[Future] \" + ChatFormatting.GREEN + player.getName() + ChatFormatting.GRAY + \" just popped \" + ChatFormatting.GREEN + l_Count + ChatFormatting.GRAY + \" totem.\";\r\n                    }\r\n                    case PHOBOS: {\r\n                        return ChatFormatting.GOLD + player.getName() + ChatFormatting.RED + \" popped \" + ChatFormatting.GOLD + l_Count + ChatFormatting.RED + \" totem.\";\r\n                    }\r\n                    case DOTGOD: {\r\n                        return ChatFormatting.DARK_PURPLE + \"[\" + ChatFormatting.LIGHT_PURPLE + \"DotGod.CC\" + ChatFormatting.DARK_PURPLE + \"] \" + ChatFormatting.LIGHT_PURPLE + player.getName() + \" has popped \" + ChatFormatting.RED + l_Count + ChatFormatting.LIGHT_PURPLE + \" time in total!\";\r\n                    }\r\n                    case NONE: {\r\n                        return HUD.getInstance().getCommandMessage() + ChatFormatting.WHITE + player.getName() + \" popped \" + ChatFormatting.GREEN + l_Count + ChatFormatting.WHITE + \" Totem.\";\r\n                    }\r\n                }\r\n            } else {\r\n                return HUD.getInstance().getCommandMessage() + ChatFormatting.WHITE + player.getName() + \" popped \" + ChatFormatting.GREEN + l_Count + ChatFormatting.WHITE + \" Totem.\";\r\n            }\r\n        } else {\r\n            if (ModuleTools.getInstance().isEnabled()) {\r\n                switch (ModuleTools.getInstance().popNotifier.getValue()) {\r\n                    case FUTURE: {\r\n                        return ChatFormatting.RED + \"[Future] \" + ChatFormatting.GREEN + player.getName() + ChatFormatting.GRAY + \" just popped \" + ChatFormatting.GREEN + l_Count + ChatFormatting.GRAY + \" totems.\";\r\n                    }\r\n                    case PHOBOS: {\r\n                        return ChatFormatting.GOLD + player.getName() + ChatFormatting.RED + \" popped \" + ChatFormatting.GOLD + l_Count + ChatFormatting.RED + \" totems.\";\r\n                    }\r\n                    case DOTGOD: {\r\n                        return ChatFormatting.DARK_PURPLE + \"[\" + ChatFormatting.LIGHT_PURPLE + \"DotGod.CC\" + ChatFormatting.DARK_PURPLE + \"] \" + ChatFormatting.LIGHT_PURPLE + player.getName() + \" has popped \" + ChatFormatting.RED + l_Count + ChatFormatting.LIGHT_PURPLE + \" times in total!\";\r\n                    }\r\n                    case NONE: {\r\n                        return ChatFormatting.WHITE + player.getName() + \" popped \" + ChatFormatting.GREEN + l_Count + ChatFormatting.WHITE + \" Totems.\";\r\n                    }\r\n                }\r\n            } else {\r\n                return HUD.getInstance().getCommandMessage() + ChatFormatting.WHITE + player.getName() + \" popped \" + ChatFormatting.GREEN + l_Count + ChatFormatting.WHITE + \" Totems.\";\r\n            }\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    public void onTotemPop(EntityPlayer player) {\r\n        if (PopCounter.fullNullCheck()) {\r\n            return;\r\n        }\r\n        if (getInstance().isDisabled())\r\n            return;\r\n        if (PopCounter.mc.player.equals(player)) {\r\n            return;\r\n        }\r\n        Command.sendSilentMessage(pop(player));\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/me/derp/quantum/features/modules/misc/PopCounter.java b/src/main/java/me/derp/quantum/features/modules/misc/PopCounter.java
--- a/src/main/java/me/derp/quantum/features/modules/misc/PopCounter.java	(revision 7b4fc7b1b7f98d347c60677eb835323ad7521d92)
+++ b/src/main/java/me/derp/quantum/features/modules/misc/PopCounter.java	(date 1636351345057)
@@ -5,6 +5,7 @@
 import me.derp.quantum.features.modules.Module;
 import me.derp.quantum.features.modules.client.HUD;
 import me.derp.quantum.features.modules.client.ModuleTools;
+import me.derp.quantum.features.setting.Setting;
 import net.minecraft.entity.player.EntityPlayer;
 
 import java.util.HashMap;
@@ -13,7 +14,7 @@
         extends Module {
     public static HashMap<String, Integer> TotemPopContainer = new HashMap<>();
     private static PopCounter INSTANCE = new PopCounter();
-
+    Setting<Boolean> self = this.register(new Setting<>("Self", false, "Shows self pops."));
 
     public PopCounter() {
         super("PopCounter", "Counts other players totem pops.", Module.Category.MISC, true, false, false);
@@ -52,12 +53,12 @@
                         return ChatFormatting.DARK_PURPLE + "[" + ChatFormatting.LIGHT_PURPLE + "DotGod.CC" + ChatFormatting.DARK_PURPLE + "] " + ChatFormatting.LIGHT_PURPLE + player.getName() + " died after popping " + ChatFormatting.GREEN + l_Count + ChatFormatting.LIGHT_PURPLE + " time!";
                     }
                     case NONE: {
-                        return HUD.getInstance().getCommandMessage() + ChatFormatting.WHITE + player.getName() + " died after popping " + ChatFormatting.GREEN + l_Count + ChatFormatting.WHITE + " Totem!";
+                        return HUD.getInstance().getCommandMessage() + "LOL, " + player.getName() + " just fucking died after popping " + l_Count + " totem, what a loser.";
 
                     }
                 }
             } else {
-                return HUD.getInstance().getCommandMessage() + ChatFormatting.WHITE + player.getName() + " died after popping " + ChatFormatting.GREEN + l_Count + ChatFormatting.WHITE + " Totem!";
+                return HUD.getInstance().getCommandMessage() + "LOL, " + player.getName() + " just fucking died after popping " + l_Count + " totems, what a loser.";
 
             }
         } else {
@@ -73,13 +74,12 @@
                         return ChatFormatting.DARK_PURPLE + "[" + ChatFormatting.LIGHT_PURPLE + "DotGod.CC" + ChatFormatting.DARK_PURPLE + "] " + ChatFormatting.LIGHT_PURPLE + player.getName() + " died after popping " + ChatFormatting.GREEN + l_Count + ChatFormatting.LIGHT_PURPLE + " times!";
                     }
                     case NONE: {
-                        return HUD.getInstance().getCommandMessage() + ChatFormatting.WHITE + player.getName() + " died after popping " + ChatFormatting.GREEN + l_Count + ChatFormatting.WHITE + " Totems!";
+                        return HUD.getInstance().getCommandMessage() + "LOL, " + player.getName() + " just fucking died after popping " + l_Count + " totems, what a loser.";
 
                     }
                 }
             } else {
-                return HUD.getInstance().getCommandMessage() + ChatFormatting.WHITE + player.getName() + " died after popping " + ChatFormatting.GREEN + l_Count + ChatFormatting.WHITE + " Totems!";
-            }
+                return HUD.getInstance().getCommandMessage() + "LOL, " + player.getName() + " just fucking died after popping " + l_Count + " totems, what a loser.";}
         }
         return null;
     }
@@ -90,8 +90,10 @@
         }
         if (getInstance().isDisabled())
             return;
-        if (PopCounter.mc.player.equals(player)) {
-            return;
+        if (!self.getValue()) {
+            if (PopCounter.mc.player.equals(player)) {
+                return;
+            }
         }
         if (TotemPopContainer.containsKey(player.getName())) {
             Command.sendSilentMessage(death1(player));
Index: src/main/java/me/derp/quantum/features/modules/client/Welcomer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/me/derp/quantum/features/modules/client/Welcomer.java b/src/main/java/me/derp/quantum/features/modules/client/Welcomer.java
new file mode 100644
--- /dev/null	(date 1635853761583)
+++ b/src/main/java/me/derp/quantum/features/modules/client/Welcomer.java	(date 1635853761583)
@@ -0,0 +1,15 @@
+package me.derp.quantum.features.modules.client;
+
+import me.derp.quantum.util.ColorUtil;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.Gui;
+import net.minecraft.client.gui.GuiScreen;
+import net.minecraftforge.client.event.RenderGameOverlayEvent;
+
+public class Welcomer {
+    Minecraft mc = Minecraft.getMinecraft();
+
+    public void onTextRender(RenderGameOverlayEvent.Text event) {
+        mc.fontRenderer.drawString("[codex.vevo]: welcome to da hack, " + mc.player.getName() + ".", 450 / 2 - mc.fontRenderer.getStringWidth("[codex.vevo]: welcome to da hack, " + mc.player.getName() + "."), 10, ColorUtil.rainbow(50).hashCode());
+    }
+}
Index: src/main/java/me/derp/quantum/features/modules/player/TickShift.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/me/derp/quantum/features/modules/player/TickShift.java b/src/main/java/me/derp/quantum/features/modules/player/TickShift.java
new file mode 100644
--- /dev/null	(date 1635855964923)
+++ b/src/main/java/me/derp/quantum/features/modules/player/TickShift.java	(date 1635855964923)
@@ -0,0 +1,18 @@
+package me.derp.quantum.features.modules.player;
+
+import net.minecraft.client.Minecraft;
+import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
+import net.minecraftforge.fml.common.gameevent.TickEvent;
+
+public class TickShift {
+    Minecraft mc = Minecraft.getMinecraft();
+    int ticks = 0;
+    @SubscribeEvent
+    public void onTickUpdate(TickEvent.ClientTickEvent event) {
+        if (ticks <= 0) ticks = 0;
+        if (!isMoving()) ticks++;
+        if (isMoving() && ticks != 0) { mc.timer.tickLength = 25; }
+    }
+
+    boolean isMoving() { return mc.player.motionX != 0 && mc.player.motionZ != 0; }
+}
Index: src/main/java/me/derp/quantum/features/command/commands/QueueCommand.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package me.derp.quantum.features.command.commands;\r\n\r\nimport com.google.gson.JsonElement;\r\nimport com.google.gson.JsonObject;\r\nimport com.google.gson.JsonParser;\r\nimport me.derp.quantum.features.command.Command;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.net.HttpURLConnection;\r\nimport java.net.URL;\r\n\r\npublic\r\nclass QueueCommand extends Command {\r\n    public\r\n    QueueCommand() {\r\n        super(\"queue\", new String[]{\"priority, regular\"});\r\n    }\r\n\r\n    @Override\r\n    public\r\n    void execute(final String[] commands) {\r\n        if (commands.length == 1 || commands.length == 0) {\r\n            QueueCommand.sendMessage(\"ayo, specify the type! (priority/regular)\");\r\n            return;\r\n        }\r\n\r\n        // Connect to the URL using java's native library\r\n        String check = commands[0];\r\n        if (check.equalsIgnoreCase(\"regular\")) {\r\n            try {\r\n                HttpURLConnection request = (HttpURLConnection) new URL(\"https://2bqueue.info/*\").openConnection();\r\n                request.addRequestProperty(\"User-Agent\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)\");\r\n                request.connect();\r\n                JsonParser jp = new JsonParser(); //from gson\r\n                JsonElement root = jp.parse(new BufferedReader(new InputStreamReader(request.getInputStream()))); //Convert the input stream to a json element\r\n                JsonObject rootobj = root.getAsJsonObject(); //May be an array, may be an object.\r\n                String aaaaaa = rootobj.get(\"regular\").getAsString(); //just grab the zipcode\r\n                QueueCommand.sendMessage(\"Regular queue currently have: \" + aaaaaa);\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        } else if (check.equalsIgnoreCase(\"priority\")) {\r\n            try {\r\n                HttpURLConnection request = (HttpURLConnection) new URL(\"https://2bqueue.info/*\").openConnection();\r\n                request.addRequestProperty(\"User-Agent\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)\");\r\n                request.connect();\r\n                JsonParser jp = new JsonParser(); //from gson\r\n                JsonElement root = jp.parse(new BufferedReader(new InputStreamReader(request.getInputStream()))); //Convert the input stream to a json element\r\n                JsonObject rootobj = root.getAsJsonObject(); //May be an array, may be an object.\r\n                String aaaaaa = rootobj.get(\"prio\").getAsString(); //just grab the zipcode\r\n                QueueCommand.sendMessage(\"Priority queue currently have: \" + aaaaaa);\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/me/derp/quantum/features/command/commands/QueueCommand.java b/src/main/java/me/derp/quantum/features/command/commands/QueueCommand.java
--- a/src/main/java/me/derp/quantum/features/command/commands/QueueCommand.java	(revision 7b4fc7b1b7f98d347c60677eb835323ad7521d92)
+++ b/src/main/java/me/derp/quantum/features/command/commands/QueueCommand.java	(date 1636349345672)
@@ -1,15 +1,7 @@
 package me.derp.quantum.features.command.commands;
 
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParser;
 import me.derp.quantum.features.command.Command;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.net.HttpURLConnection;
-import java.net.URL;
+import java.util.Random;
 
 public
 class QueueCommand extends Command {
@@ -22,38 +14,35 @@
     public
     void execute(final String[] commands) {
         if (commands.length == 1 || commands.length == 0) {
-            QueueCommand.sendMessage("ayo, specify the type! (priority/regular)");
+            sendMessage("RPS > specify type u monke");
             return;
         }
-
-        // Connect to the URL using java's native library
+        Random rng = new Random();
+        int rngNumber = rng.nextInt(3);
         String check = commands[0];
-        if (check.equalsIgnoreCase("regular")) {
-            try {
-                HttpURLConnection request = (HttpURLConnection) new URL("https://2bqueue.info/*").openConnection();
-                request.addRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)");
-                request.connect();
-                JsonParser jp = new JsonParser(); //from gson
-                JsonElement root = jp.parse(new BufferedReader(new InputStreamReader(request.getInputStream()))); //Convert the input stream to a json element
-                JsonObject rootobj = root.getAsJsonObject(); //May be an array, may be an object.
-                String aaaaaa = rootobj.get("regular").getAsString(); //just grab the zipcode
-                QueueCommand.sendMessage("Regular queue currently have: " + aaaaaa);
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        } else if (check.equalsIgnoreCase("priority")) {
-            try {
-                HttpURLConnection request = (HttpURLConnection) new URL("https://2bqueue.info/*").openConnection();
-                request.addRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)");
-                request.connect();
-                JsonParser jp = new JsonParser(); //from gson
-                JsonElement root = jp.parse(new BufferedReader(new InputStreamReader(request.getInputStream()))); //Convert the input stream to a json element
-                JsonObject rootobj = root.getAsJsonObject(); //May be an array, may be an object.
-                String aaaaaa = rootobj.get("prio").getAsString(); //just grab the zipcode
-                QueueCommand.sendMessage("Priority queue currently have: " + aaaaaa);
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
+        if (check.equalsIgnoreCase("rock")) {
+            String value = getValue(rngNumber);
+            if (value.equalsIgnoreCase("Rock")) sendSilentMessage("RPS > u draw noob");
+            if (value.equalsIgnoreCase("Paper")) sendSilentMessage("RPS > LOL, you lose. what a loser");
+            if (value.equalsIgnoreCase("Scissors")) sendSilentMessage("RPS > u won :O");
+        } else if (check.equalsIgnoreCase("paper")) {
+            String value = getValue(rngNumber);
+            if (value.equalsIgnoreCase("Paper")) sendSilentMessage("RPS > u draw noob");
+            if (value.equalsIgnoreCase("Scissors")) sendSilentMessage("RPS > LOL, you lose. what a loser");
+            if (value.equalsIgnoreCase("Rock")) sendSilentMessage("RPS > u won :O");
+        } else if (check.equalsIgnoreCase("scissors")) {
+            String value = getValue(rngNumber);
+            if (value.equalsIgnoreCase("Scissors")) sendSilentMessage("RPS > u draw noob");
+            if (value.equalsIgnoreCase("Rock")) sendSilentMessage("RPS > LOL, you lose. what a loser");
+            if (value.equalsIgnoreCase("Paper")) sendSilentMessage("RPS > u won :O");
+        } else {
+            sendSilentMessage("RPS > lol use rock/paper/scissors");
+        }
+    }
+
+    String getValue(int a) {
+        if (a == 1) return "Rock";
+        if (a == 2) return "Paper";
+        return "Scissors";
     }
 }
\ No newline at end of file
Index: src/main/java/me/derp/quantum/mixin/mixins/MixinRenderLivingBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package me.derp.quantum.mixin.mixins;\r\n\r\nimport me.derp.quantum.Quantum;\r\nimport me.derp.quantum.features.modules.client.ClickGui;\r\nimport me.derp.quantum.features.modules.render.PopChams;\r\nimport me.derp.quantum.features.modules.render.Wireframe;\r\nimport me.derp.quantum.util.ColorUtil;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.model.ModelBase;\r\nimport net.minecraft.client.renderer.GlStateManager;\r\nimport net.minecraft.client.renderer.OpenGlHelper;\r\nimport net.minecraft.client.renderer.entity.Render;\r\nimport net.minecraft.client.renderer.entity.RenderLivingBase;\r\nimport net.minecraft.client.renderer.entity.RenderManager;\r\nimport net.minecraft.entity.EntityLivingBase;\r\nimport net.minecraft.entity.player.EntityPlayer;\r\nimport net.minecraft.util.ResourceLocation;\r\nimport net.minecraft.util.math.MathHelper;\r\nimport net.minecraftforge.client.event.RenderLivingEvent;\r\nimport net.minecraftforge.common.MinecraftForge;\r\nimport org.lwjgl.opengl.GL11;\r\nimport org.spongepowered.asm.mixin.Mixin;\r\nimport org.spongepowered.asm.mixin.Overwrite;\r\nimport org.spongepowered.asm.mixin.Shadow;\r\nimport org.spongepowered.asm.mixin.injection.At;\r\nimport org.spongepowered.asm.mixin.injection.Inject;\r\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\r\n\r\nimport java.awt.*;\r\n\r\nimport static org.lwjgl.opengl.GL11.*;\r\n\r\n@Mixin({RenderLivingBase.class})\r\npublic abstract class MixinRenderLivingBase<T extends EntityLivingBase> extends Render<T> {\r\n\r\n\r\n    @Shadow\r\n    protected abstract void renderModel(T entitylivingbaseIn, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor);\r\n\r\n    @Shadow\r\n    protected abstract void renderLayers(T entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scaleIn);\r\n\r\n    @Shadow\r\n    protected abstract void unsetBrightness();\r\n\r\n    @Shadow\r\n    protected abstract boolean setDoRenderBrightness(T entityLivingBaseIn, float partialTicks);\r\n\r\n    @Shadow\r\n    protected ModelBase mainModel;\r\n\r\n    @Shadow\r\n    protected abstract float getSwingProgress(T livingBase, float partialTickTime);\r\n\r\n    @Shadow\r\n    protected abstract float interpolateRotation(float prevYawOffset, float yawOffset, float partialTicks);\r\n\r\n    @Shadow\r\n    protected abstract void renderLivingAt(T entityLivingBaseIn, double x, double y, double z);\r\n\r\n    @Shadow\r\n    protected abstract float handleRotationFloat(T livingBase, float partialTicks);\r\n\r\n    @Shadow\r\n    protected abstract void applyRotations(T entityLiving, float ageInTicks, float rotationYaw, float partialTicks);\r\n\r\n    @Shadow\r\n    public abstract float prepareScale(T entitylivingbaseIn, float partialTicks);\r\n\r\n    @Shadow\r\n    protected abstract boolean setScoreTeamColor(T entityLivingBaseIn);\r\n\r\n    @Shadow\r\n    protected boolean renderMarker;\r\n\r\n    @Shadow\r\n    protected abstract void unsetScoreTeamColor();\r\n\r\n    float red;\r\n\r\n    float green;\r\n\r\n    float blue;\r\n\r\n    protected MixinRenderLivingBase(RenderManager renderManager) {\r\n        super(renderManager);\r\n        this.red = 0.0F;\r\n        this.green = 0.0F;\r\n        this.blue = 0.0F;\r\n\r\n\r\n    }\r\n\r\n\r\n    private static final ResourceLocation glint = new ResourceLocation(\"textures/shinechams.png\");\r\n\r\n    public MixinRenderLivingBase(RenderManager renderManagerIn, ModelBase modelBaseIn, float shadowSizeIn) {\r\n        super(renderManagerIn);\r\n    }\r\n\r\n\r\n    /**\r\n     * @author d\r\n     */\r\n    @Overwrite\r\n    public void doRender(T entity, double x, double y, double z, float entityYaw, float partialTicks) {\r\n        if (!MinecraftForge.EVENT_BUS.post(new RenderLivingEvent.Pre(entity, RenderLivingBase.class.cast(this), partialTicks, x, y, z))) {\r\n            GlStateManager.pushMatrix();\r\n            GlStateManager.disableCull();\r\n            this.mainModel.swingProgress = getSwingProgress(entity, partialTicks);\r\n            boolean shouldSit = (entity.isRiding() && entity.getRidingEntity() != null && entity.getRidingEntity().shouldRiderSit());\r\n            this.mainModel.isRiding = shouldSit;\r\n            this.mainModel.isChild = entity.isChild();\r\n            try {\r\n                float f = interpolateRotation(entity.prevRenderYawOffset, entity.renderYawOffset, partialTicks);\r\n                float f1 = interpolateRotation(entity.prevRotationYawHead, entity.rotationYawHead, partialTicks);\r\n                float f2 = f1 - f;\r\n                if (shouldSit && entity.getRidingEntity() instanceof EntityLivingBase) {\r\n                    EntityLivingBase entitylivingbase = (EntityLivingBase) entity.getRidingEntity();\r\n                    f = interpolateRotation(entitylivingbase.prevRenderYawOffset, entitylivingbase.renderYawOffset, partialTicks);\r\n                    f2 = f1 - f;\r\n                    float f3 = MathHelper.wrapDegrees(f2);\r\n                    if (f3 < -85.0F)\r\n                        f3 = -85.0F;\r\n                    if (f3 >= 85.0F)\r\n                        f3 = 85.0F;\r\n                    f = f1 - f3;\r\n                    if (f3 * f3 > 2500.0F)\r\n                        f += f3 * 0.2F;\r\n                    f2 = f1 - f;\r\n                }\r\n                float f7 = entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks;\r\n                renderLivingAt(entity, x, y, z);\r\n                float f8 = handleRotationFloat(entity, partialTicks);\r\n                applyRotations(entity, f8, f, partialTicks);\r\n                float f4 = prepareScale(entity, partialTicks);\r\n                float f5 = 0.0F;\r\n                float f6 = 0.0F;\r\n                if (!entity.isRiding()) {\r\n                    f5 = entity.prevLimbSwingAmount + (entity.limbSwingAmount - entity.prevLimbSwingAmount) * partialTicks;\r\n                    f6 = entity.limbSwing - entity.limbSwingAmount * (1.0F - partialTicks);\r\n                    if (entity.isChild())\r\n                        f6 *= 3.0F;\r\n                    if (f5 > 1.0F)\r\n                        f5 = 1.0F;\r\n                    f2 = f1 - f;\r\n                }\r\n                GlStateManager.enableAlpha();\r\n                this.mainModel.setLivingAnimations(entity, f6, f5, partialTicks);\r\n                this.mainModel.setRotationAngles(f6, f5, f8, f2, f7, f4, entity);\r\n                if (this.renderOutlines) {\r\n                    boolean flag1 = setScoreTeamColor(entity);\r\n                    GlStateManager.enableColorMaterial();\r\n                    GlStateManager.enableOutlineMode(getTeamColor(entity));\r\n                    if (!this.renderMarker)\r\n                        renderModel(entity, f6, f5, f8, f2, f7, f4);\r\n                    if (!(entity instanceof EntityPlayer) || !((EntityPlayer) entity).isSpectator())\r\n                        renderLayers(entity, f6, f5, partialTicks, f8, f2, f7, f4);\r\n                    GlStateManager.disableOutlineMode();\r\n                    GlStateManager.disableColorMaterial();\r\n                    if (flag1)\r\n                        unsetScoreTeamColor();\r\n                } else {\r\n                    if (Wireframe.getINSTANCE().isOn() && (Wireframe.getINSTANCE()).players.getValue() && entity instanceof EntityPlayer && (Wireframe.getINSTANCE()).mode.getValue().equals(Wireframe.RenderMode.SOLID)) {\r\n                        this.red = (ClickGui.getInstance()).red.getValue() / 255.0F;\r\n                        this.green = (ClickGui.getInstance()).green.getValue() / 255.0F;\r\n                        this.blue = (ClickGui.getInstance()).blue.getValue() / 255.0F;\r\n                        GlStateManager.pushMatrix();\r\n                        GL11.glPushAttrib(1048575);\r\n                        GL11.glDisable(3553);\r\n                        GL11.glDisable(2896);\r\n                        GL11.glEnable(2848);\r\n                        GL11.glEnable(3042);\r\n                        GL11.glBlendFunc(770, 771);\r\n                        GL11.glDisable(2929);\r\n                        GL11.glDepthMask(false);\r\n                        if (Quantum.friendManager.isFriend(entity.getName()) || entity == (Minecraft.getMinecraft()).player) {\r\n                            GL11.glColor4f(0.0F, 191.0F, 255.0F, (Wireframe.getINSTANCE()).alpha.getValue() / 255.0F);\r\n                        } else {\r\n                            GL11.glColor4f((ClickGui.getInstance()).rainbow.getValue() ? (ColorUtil.rainbow((ClickGui.getInstance()).rainbowHue.getValue()).getRed() / 255.0F) : this.red, (ClickGui.getInstance()).rainbow.getValue() ? (ColorUtil.rainbow((ClickGui.getInstance()).rainbowHue.getValue()).getGreen() / 255.0F) : this.green, (ClickGui.getInstance()).rainbow.getValue() ? (ColorUtil.rainbow((ClickGui.getInstance()).rainbowHue.getValue()).getBlue() / 255.0F) : this.blue, (Wireframe.getINSTANCE()).alpha.getValue() / 255.0F);\r\n                        }\r\n                        renderModel(entity, f6, f5, f8, f2, f7, f4);\r\n                        GL11.glDisable(2896);\r\n                        GL11.glEnable(2929);\r\n                        GL11.glDepthMask(true);\r\n                        if (Quantum.friendManager.isFriend(entity.getName()) || entity == (Minecraft.getMinecraft()).player) {\r\n                            GL11.glColor4f(0.0F, 191.0F, 255.0F, (Wireframe.getINSTANCE()).alpha.getValue() / 255.0F);\r\n                        } else {\r\n                            GL11.glColor4f((ClickGui.getInstance()).rainbow.getValue() ? (ColorUtil.rainbow((ClickGui.getInstance()).rainbowHue.getValue()).getRed() / 255.0F) : this.red, (ClickGui.getInstance()).rainbow.getValue() ? (ColorUtil.rainbow((ClickGui.getInstance()).rainbowHue.getValue()).getGreen() / 255.0F) : this.green, (ClickGui.getInstance()).rainbow.getValue() ? (ColorUtil.rainbow((ClickGui.getInstance()).rainbowHue.getValue()).getBlue() / 255.0F) : this.blue, (Wireframe.getINSTANCE()).alpha.getValue() / 255.0F);\r\n                        }\r\n                        renderModel(entity, f6, f5, f8, f2, f7, f4);\r\n                        GL11.glEnable(2896);\r\n                        GlStateManager.popAttrib();\r\n                        GlStateManager.popMatrix();\r\n                    }\r\n                    boolean flag1 = setDoRenderBrightness(entity, partialTicks);\r\n                    if (!(entity instanceof EntityPlayer) || (Wireframe.getINSTANCE().isOn() && (Wireframe.getINSTANCE()).mode.getValue().equals(Wireframe.RenderMode.WIREFRAME) && (Wireframe.getINSTANCE()).playerModel.getValue()) || Wireframe.getINSTANCE().isOff())\r\n                        renderModel(entity, f6, f5, f8, f2, f7, f4);\r\n                    if (flag1)\r\n                        unsetBrightness();\r\n                    GlStateManager.depthMask(true);\r\n                    if (!(entity instanceof EntityPlayer) || !((EntityPlayer) entity).isSpectator())\r\n                        renderLayers(entity, f6, f5, partialTicks, f8, f2, f7, f4);\r\n                    if (Wireframe.getINSTANCE().isOn() && (Wireframe.getINSTANCE()).players.getValue() && entity instanceof EntityPlayer && (Wireframe.getINSTANCE()).mode.getValue().equals(Wireframe.RenderMode.WIREFRAME)) {\r\n                        this.red = (ClickGui.getInstance()).red.getValue() / 255.0F;\r\n                        this.green = (ClickGui.getInstance()).green.getValue() / 255.0F;\r\n                        this.blue = (ClickGui.getInstance()).blue.getValue() / 255.0F;\r\n                        GlStateManager.pushMatrix();\r\n                        GL11.glPushAttrib(1048575);\r\n                        GL11.glPolygonMode(1032, 6913);\r\n                        GL11.glDisable(3553);\r\n                        GL11.glDisable(2896);\r\n                        GL11.glDisable(2929);\r\n                        GL11.glEnable(2848);\r\n                        GL11.glEnable(3042);\r\n                        GL11.glBlendFunc(770, 771);\r\n                        if (Quantum.friendManager.isFriend(entity.getName()) || entity == (Minecraft.getMinecraft()).player) {\r\n                            GL11.glColor4f(0.0F, 191.0F, 255.0F, (Wireframe.getINSTANCE()).alpha.getValue() / 255.0F);\r\n                        } else {\r\n                            GL11.glColor4f((ClickGui.getInstance()).rainbow.getValue() ? (ColorUtil.rainbow((ClickGui.getInstance()).rainbowHue.getValue()).getRed() / 255.0F) : this.red, (ClickGui.getInstance()).rainbow.getValue() ? (ColorUtil.rainbow((ClickGui.getInstance()).rainbowHue.getValue()).getGreen() / 255.0F) : this.green, (ClickGui.getInstance()).rainbow.getValue() ? (ColorUtil.rainbow((ClickGui.getInstance()).rainbowHue.getValue()).getBlue() / 255.0F) : this.blue, (Wireframe.getINSTANCE()).alpha.getValue() / 255.0F);\r\n                        }\r\n                        GL11.glLineWidth((Wireframe.getINSTANCE()).lineWidth.getValue());\r\n                        renderModel(entity, f6, f5, f8, f2, f7, f4);\r\n                        GL11.glEnable(2896);\r\n                        GlStateManager.popAttrib();\r\n                        GlStateManager.popMatrix();\r\n                    }\r\n                }\r\n                GlStateManager.disableRescaleNormal();\r\n            } catch (Exception var20) {\r\n                Quantum.LOGGER.error(\"Couldn't render entity\", var20);\r\n            }\r\n            GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);\r\n            GlStateManager.enableTexture2D();\r\n            GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);\r\n            GlStateManager.enableCull();\r\n            GlStateManager.popMatrix();\r\n            super.doRender(entity, x, y, z, entityYaw, partialTicks);\r\n            MinecraftForge.EVENT_BUS.post(new RenderLivingEvent.Post(entity, RenderLivingBase.class.cast(this), partialTicks, x, y, z));\r\n        }\r\n    }\r\n\r\n\r\n    @Inject(method = {\"renderModel\"}, at = {@At(value = \"INVOKE\", target = \"Lnet/minecraft/client/model/ModelBase;render(Lnet/minecraft/entity/Entity;FFFFFF)V\")}, cancellable = true)\r\n    private void renderModel(EntityLivingBase entity, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, CallbackInfo info) {\r\n        if (PopChams.pops.containsKey(entity.getEntityId())) {\r\n            if (PopChams.pops.get(entity.getEntityId()) == 0) {\r\n                Minecraft.getMinecraft().world.removeEntityFromWorld(entity.entityId);\r\n            } else if (PopChams.pops.get(entity.getEntityId()) < 0) {\r\n                //this is retarted but it doesnt instantly stop rendering sorry for messy code dont remove this\r\n                if (PopChams.pops.get(entity.getEntityId()) < -5)\r\n                    PopChams.pops.remove(entity.getEntityId());\r\n                return;\r\n            }\r\n            GlStateManager.enableBlendProfile(GlStateManager.Profile.TRANSPARENT_MODEL);\r\n            glPushMatrix();\r\n            glPushAttrib(GL_ALL_ATTRIB_BITS);\r\n            glDisable(GL_TEXTURE_2D);\r\n            glEnable(GL_LINE_SMOOTH);\r\n            glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);\r\n            GL11.glDisable(2929);\r\n            GL11.glEnable(10754);\r\n            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);\r\n            new Color(PopChams.INSTANCE.red.getValue(), PopChams.INSTANCE.green.getValue(), PopChams.INSTANCE.blue.getValue(), PopChams.pops.get(entity.getEntityId()));\r\n            mainModel.render(entity, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor);\r\n            GL11.glEnable(2929);\r\n            glEnable(GL_TEXTURE_2D);\r\n            glPopAttrib();\r\n            glPopMatrix();\r\n            PopChams.pops.computeIfPresent(entity.getEntityId(), (key, oldValue) -> oldValue - 1);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/me/derp/quantum/mixin/mixins/MixinRenderLivingBase.java b/src/main/java/me/derp/quantum/mixin/mixins/MixinRenderLivingBase.java
--- a/src/main/java/me/derp/quantum/mixin/mixins/MixinRenderLivingBase.java	(revision 7b4fc7b1b7f98d347c60677eb835323ad7521d92)
+++ b/src/main/java/me/derp/quantum/mixin/mixins/MixinRenderLivingBase.java	(date 1636430490196)
@@ -239,37 +239,6 @@
             MinecraftForge.EVENT_BUS.post(new RenderLivingEvent.Post(entity, RenderLivingBase.class.cast(this), partialTicks, x, y, z));
         }
     }
-
-
-    @Inject(method = {"renderModel"}, at = {@At(value = "INVOKE", target = "Lnet/minecraft/client/model/ModelBase;render(Lnet/minecraft/entity/Entity;FFFFFF)V")}, cancellable = true)
-    private void renderModel(EntityLivingBase entity, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, CallbackInfo info) {
-        if (PopChams.pops.containsKey(entity.getEntityId())) {
-            if (PopChams.pops.get(entity.getEntityId()) == 0) {
-                Minecraft.getMinecraft().world.removeEntityFromWorld(entity.entityId);
-            } else if (PopChams.pops.get(entity.getEntityId()) < 0) {
-                //this is retarted but it doesnt instantly stop rendering sorry for messy code dont remove this
-                if (PopChams.pops.get(entity.getEntityId()) < -5)
-                    PopChams.pops.remove(entity.getEntityId());
-                return;
-            }
-            GlStateManager.enableBlendProfile(GlStateManager.Profile.TRANSPARENT_MODEL);
-            glPushMatrix();
-            glPushAttrib(GL_ALL_ATTRIB_BITS);
-            glDisable(GL_TEXTURE_2D);
-            glEnable(GL_LINE_SMOOTH);
-            glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
-            GL11.glDisable(2929);
-            GL11.glEnable(10754);
-            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
-            new Color(PopChams.INSTANCE.red.getValue(), PopChams.INSTANCE.green.getValue(), PopChams.INSTANCE.blue.getValue(), PopChams.pops.get(entity.getEntityId()));
-            mainModel.render(entity, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor);
-            GL11.glEnable(2929);
-            glEnable(GL_TEXTURE_2D);
-            glPopAttrib();
-            glPopMatrix();
-            PopChams.pops.computeIfPresent(entity.getEntityId(), (key, oldValue) -> oldValue - 1);
-        }
-    }
 }
 
 
